:NewDefs


// * Adapted example from Code reuse through polymorphic variants (FOSE 2000)


class Cons[out A](head: A, tail: Cons[A] | Nil)
module Nil
//│ class Cons[A](head: A, tail: Cons[A] | Nil)
//│ module Nil

let l = Cons(1, Nil)
//│ let l: Cons[1]
//│ l
//│   = Cons {}

class NotFound()
class Success[out A](result: A)
//│ class NotFound()
//│ class Success[A](result: A)

fun list_assoc(s, l) =
  if l is
    Cons(h, t) then
      if s === h._1 then Success(h._2)
      else list_assoc(s, t)
    Nil then NotFound()
//│ ╔══[ERROR] Type `A` does not contain member `_2`
//│ ║  l.25: 	      if s === h._1 then Success(h._2)
//│ ╙──      	                                  ^^^
//│ fun list_assoc: (Eql[error], Cons[anything] | Nil) -> (NotFound | Success[error] | error)

// fun list_assoc(s: Str, l: Cons[{ _1: Str, _2: 'b }] | Nil): NotFound | Success['b]

class Var(s: Str)
//│ class Var(s: Str)

mixin EvalVar {
  fun eval(sub, v) =
    if v is Var(s) then
      if list_assoc(s, sub) is
        NotFound then v
        Success(r) then r
}
//│ mixin EvalVar() {
//│   fun eval: (Cons[anything] | Nil, Var) -> (Var | error & ??A)
//│ }

class Abs[A](x: Str, t: A)
class App[A](s: A, t: A)
//│ class Abs[A](x: Str, t: A)
//│ class App[A](s: A, t: A)

fun gensym(): Str = "fun"
//│ fun gensym: () -> Str

fun int_to_string(x: Int): Str = "0"
//│ fun int_to_string: (x: Int) -> Str

mixin EvalLambda {
  fun eval(sub, v) =
    if v is
      App(t1, t2) then
        let l1 = this.eval(sub, t1)
        let l2 = this.eval(sub, t2)
        if t1 is
          Abs(x, t) then this.eval(Cons([x, l2], Nil), t)
        else
          App(l1, l2)
      Abs(x, t) then
        let s = gensym()
        Abs(s, this.eval(Cons([x, Var(s)], sub), t))
    else
      super.eval(sub, v)
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.62: 	    if v is
//│ ║        	       ^^^^
//│ ║  l.63: 	      App(t1, t2) then
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.64: 	        let l1 = this.eval(sub, t1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.65: 	        let l2 = this.eval(sub, t2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.66: 	        if t1 is
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.67: 	          Abs(x, t) then this.eval(Cons([x, l2], Nil), t)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.68: 	        else
//│ ║        	^^^^^^^^^^^^
//│ ║  l.69: 	          App(l1, l2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `A & ?A` is not an instance of type `Object`
//│ ║  l.50: 	class App[A](s: A, t: A)
//│ ║        	             ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.66: 	        if t1 is
//│ ║        	           ^^^^^
//│ ║  l.67: 	          Abs(x, t) then this.eval(Cons([x, l2], Nil), t)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.68: 	        else
//│ ║        	^^^^^^^^^^^^
//│ ║  l.69: 	          App(l1, l2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.66: 	        if t1 is
//│ ╙──      	           ^^
//│ mixin EvalLambda() {
//│   super: {eval: ('a, 'b) -> 'c}
//│   this: {
//│     eval: ('a, ??A & 'A) -> ('d & 'e) & (Cons[[Str, 'e]], ??A0 & ??A1) -> 'c & (Cons[[Str, Var] | 'A0], ??A2 & 'A1) -> 'f
//│   }
//│   fun eval: ('a & (Cons['A0] | Nil), Abs['A1] | App['A] | Object & 'b & ~#Abs & ~#App) -> (Abs['f] | App['d | 'e] | error | 'c)
//│ }

module Test1 extends EvalVar, EvalLambda
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.116: 	module Test1 extends EvalVar, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` is not an instance of type `Var`
//│ ╟── Note: constraint arises from class pattern:
//│ ║  l.40: 	    if v is Var(s) then
//│ ║        	            ^^^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.116: 	module Test1 extends EvalVar, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.40: 	    if v is Var(s) then
//│ ║        	       ^^^^^^^^^^^^^^^^
//│ ║  l.41: 	      if list_assoc(s, sub) is
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.42: 	        NotFound then v
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.43: 	        Success(r) then r
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `App[anything] & ??A` does not contain member `Abs#A`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.116: 	module Test1 extends EvalVar, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Abs[?A0] & {Abs#A :> ?A1 <: ?A0} | App[?A2] & {App#A :> ?A3 <: ?A2} | ?a & ~#Abs & ~#App`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type `Abs[anything] & ??A` does not contain member `App#A`
//│ ║  l.50: 	class App[A](s: A, t: A)
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.116: 	module Test1 extends EvalVar, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Abs[?A0] & {Abs#A :> ?A1 <: ?A0} | App[?A2] & {App#A :> ?A3 <: ?A2} | ?a & ~#Abs & ~#App`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.116: 	module Test1 extends EvalVar, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` is not an instance of type `Object`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.62: 	    if v is
//│ ║        	       ^^^^
//│ ║  l.63: 	      App(t1, t2) then
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.64: 	        let l1 = this.eval(sub, t1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.65: 	        let l2 = this.eval(sub, t2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.66: 	        if t1 is
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.67: 	          Abs(x, t) then this.eval(Cons([x, l2], Nil), t)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.68: 	        else
//│ ║        	^^^^^^^^^^^^
//│ ║  l.69: 	          App(l1, l2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.70: 	      Abs(x, t) then
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.71: 	        let s = gensym()
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.72: 	        Abs(s, this.eval(Cons([x, Var(s)], sub), t))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.73: 	    else
//│ ║        	^^^^^^^^
//│ ║  l.74: 	      super.eval(sub, v)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.116: 	module Test1 extends EvalVar, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` is not an instance of type `Var`
//│ ╟── Note: constraint arises from class pattern:
//│ ║  l.40: 	    if v is Var(s) then
//│ ║        	            ^^^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.116: 	module Test1 extends EvalVar, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.40: 	    if v is Var(s) then
//│ ║        	       ^^^^^^^^^^^^^^^^
//│ ║  l.41: 	      if list_assoc(s, sub) is
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.42: 	        NotFound then v
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.43: 	        Success(r) then r
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `App[anything] & ??A` does not contain member `Abs#A`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.116: 	module Test1 extends EvalVar, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Abs[?A0] & {Abs#A :> ?A1 <: ?A0} | App[?A2] & {App#A :> ?A3 <: ?A2} | ?a & ~#Abs & ~#App`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type `Abs[anything] & ??A` does not contain member `App#A`
//│ ║  l.50: 	class App[A](s: A, t: A)
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.116: 	module Test1 extends EvalVar, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Abs[?A0] & {Abs#A :> ?A1 <: ?A0} | App[?A2] & {App#A :> ?A3 <: ?A2} | ?a & ~#Abs & ~#App`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.116: 	module Test1 extends EvalVar, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` is not an instance of type `Object`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.62: 	    if v is
//│ ║        	       ^^^^
//│ ║  l.63: 	      App(t1, t2) then
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.64: 	        let l1 = this.eval(sub, t1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.65: 	        let l2 = this.eval(sub, t2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.66: 	        if t1 is
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.67: 	          Abs(x, t) then this.eval(Cons([x, l2], Nil), t)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.68: 	        else
//│ ║        	^^^^^^^^^^^^
//│ ║  l.69: 	          App(l1, l2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.70: 	      Abs(x, t) then
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.71: 	        let s = gensym()
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.72: 	        Abs(s, this.eval(Cons([x, Var(s)], sub), t))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.73: 	    else
//│ ║        	^^^^^^^^
//│ ║  l.74: 	      super.eval(sub, v)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.116: 	module Test1 extends EvalVar, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` is not an instance of type `Var`
//│ ╟── Note: constraint arises from class pattern:
//│ ║  l.40: 	    if v is Var(s) then
//│ ║        	            ^^^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.116: 	module Test1 extends EvalVar, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.40: 	    if v is Var(s) then
//│ ║        	       ^^^^^^^^^^^^^^^^
//│ ║  l.41: 	      if list_assoc(s, sub) is
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.42: 	        NotFound then v
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.43: 	        Success(r) then r
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `App[anything] & ??A` does not contain member `Abs#A`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.116: 	module Test1 extends EvalVar, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Abs[?A0] & {Abs#A :> ?A1 <: ?A0} | App[?A2] & {App#A :> ?A3 <: ?A2} | ?a & ~#Abs & ~#App`
//│ ║  l.50: 	class App[A](s: A, t: A)
//│ ║        	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type `Abs[anything] & ??A` does not contain member `App#A`
//│ ║  l.50: 	class App[A](s: A, t: A)
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.116: 	module Test1 extends EvalVar, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Abs[?A0] & {Abs#A :> ?A1 <: ?A0} | App[?A2] & {App#A :> ?A3 <: ?A2} | ?a & ~#Abs & ~#App`
//│ ║  l.50: 	class App[A](s: A, t: A)
//│ ║        	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.116: 	module Test1 extends EvalVar, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` is not an instance of type `Object`
//│ ║  l.50: 	class App[A](s: A, t: A)
//│ ║        	                   ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.62: 	    if v is
//│ ║        	       ^^^^
//│ ║  l.63: 	      App(t1, t2) then
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.64: 	        let l1 = this.eval(sub, t1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.65: 	        let l2 = this.eval(sub, t2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.66: 	        if t1 is
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.67: 	          Abs(x, t) then this.eval(Cons([x, l2], Nil), t)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.68: 	        else
//│ ║        	^^^^^^^^^^^^
//│ ║  l.69: 	          App(l1, l2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.70: 	      Abs(x, t) then
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.71: 	        let s = gensym()
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.72: 	        Abs(s, this.eval(Cons([x, Var(s)], sub), t))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.73: 	    else
//│ ║        	^^^^^^^^
//│ ║  l.74: 	      super.eval(sub, v)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ module Test1 {
//│   fun eval: (Cons[anything] | Nil, Abs[anything] | App[anything] | Var) -> 'a
//│ }
//│ where
//│   'a :> Abs['a] | App['a] | Var | error

Test1.eval(Nil, Var("a"))
//│ 'a
//│   where
//│     'a :> Abs['a] | App['a] | Var | error
//│ res
//│     = Var {}

Test1.eval(Nil, Abs("b", Var("a")))
//│ 'a
//│   where
//│     'a :> Abs['a] | App['a] | Var | error
//│ res
//│     = Abs {}

Test1.eval(Cons(["c", Var("d")], Nil), App(Abs("b", Var("b")), Var("c")))
//│ 'a
//│   where
//│     'a :> Abs['a] | App['a] | Var | error
//│ res
//│     = Var {}

Test1.eval(Cons(["c", Abs("d", Var("d"))], Nil), App(Abs("b", Var("b")), Var("c")))
//│ 'a
//│   where
//│     'a :> Abs['a] | App['a] | Var | error
//│ res
//│     = Var {}

class Numb(n: Int)
class Add[A](l: A, r: A)
class Mul[A](l: A, r: A)
//│ class Numb(n: Int)
//│ class Add[A](l: A, r: A)
//│ class Mul[A](l: A, r: A)

fun map_expr(f, v) =
  if v is
    Var then v
    Numb then v
    Add(l, r) then Add(f(l), f(r))
    Mul(l, r) then Mul(f(l), f(r))
//│ fun map_expr: forall 'A 'a 'A0 'b. ((??A & 'A) -> 'a & (??A0 & 'A0) -> 'b, Add['A] | Mul['A0] | Numb | Var) -> (Add['a] | Mul['b] | Numb | Var)

mixin EvalExpr {
  fun eval(sub, v) =
    let eta(e) = this.eval(sub, e)
    let vv = map_expr(eta, v)
    if vv is
      Var then super.eval(sub, vv)
      Add(Numb(l), Numb(r)) then Numb(l + r)
      Mul(Numb(l), Numb(r)) then Numb(l * r)
    else v
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.428: 	    if vv is
//│ ║         	       ^^^^^
//│ ║  l.429: 	      Var then super.eval(sub, vv)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.430: 	      Add(Numb(l), Numb(r)) then Numb(l + r)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.431: 	      Mul(Numb(l), Numb(r)) then Numb(l * r)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.432: 	    else v
//│ ║         	^^^^^^^^^^
//│ ╟── field selection of type `A & ?A` is not an instance of type `Object`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ║         	             ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.430: 	      Add(Numb(l), Numb(r)) then Numb(l + r)
//│ ║         	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.431: 	      Mul(Numb(l), Numb(r)) then Numb(l * r)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.432: 	    else v
//│ ║         	^^^^^^^^^^^
//│ ╟── from application:
//│ ║  l.430: 	      Add(Numb(l), Numb(r)) then Numb(l + r)
//│ ╙──       	          ^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.428: 	    if vv is
//│ ║         	       ^^^^^
//│ ║  l.429: 	      Var then super.eval(sub, vv)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.430: 	      Add(Numb(l), Numb(r)) then Numb(l + r)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.431: 	      Mul(Numb(l), Numb(r)) then Numb(l * r)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.432: 	    else v
//│ ║         	^^^^^^^^^^
//│ ╟── field selection of type `A & ?A` is not an instance of type `Object`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ║         	             ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.430: 	      Add(Numb(l), Numb(r)) then Numb(l + r)
//│ ║         	          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.431: 	      Mul(Numb(l), Numb(r)) then Numb(l * r)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.432: 	    else v
//│ ║         	^^^^^^^^^^^
//│ ╟── from application:
//│ ║  l.430: 	      Add(Numb(l), Numb(r)) then Numb(l + r)
//│ ╙──       	          ^^^^^^^
//│ mixin EvalExpr() {
//│   super: {eval: ('a, Var) -> 'b}
//│   this: {eval: ('a, ??A & 'A | ??A0 & 'A0) -> anything}
//│   fun eval: ('a, 'b & (Add['A] | Mul['A0] | Numb | Var)) -> (Numb | error | 'b)
//│ }

module Test2 extends EvalVar, EvalExpr
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.488: 	module Test2 extends EvalVar, EvalExpr
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A] & {Add#A :> ?A0 <: ?A} | Mul[?A1] & {Mul#A :> ?A2 <: ?A1} | Numb | Var`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type `??A` does not contain member `Mul#A`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.488: 	module Test2 extends EvalVar, EvalExpr
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A] & {Add#A :> ?A0 <: ?A} | Mul[?A1] & {Mul#A :> ?A2 <: ?A1} | Numb | Var`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type `??A` does not contain member `Add#A`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.488: 	module Test2 extends EvalVar, EvalExpr
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A0] & {Add#A :> ?A1 <: ?A0} | Mul[?A2] & {Mul#A :> ?A3 <: ?A2} | Numb | Var`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.488: 	module Test2 extends EvalVar, EvalExpr
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` is not an instance of type `Object`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.417: 	  if v is
//│ ║         	     ^^^^
//│ ║  l.418: 	    Var then v
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.419: 	    Numb then v
//│ ║         	^^^^^^^^^^^^^^^
//│ ║  l.420: 	    Add(l, r) then Add(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.421: 	    Mul(l, r) then Mul(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.488: 	module Test2 extends EvalVar, EvalExpr
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A0] & {Add#A :> ?A1 <: ?A0} | Mul[?A2] & {Mul#A :> ?A3 <: ?A2} | Numb | Var`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type `??A` does not contain member `Mul#A`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.488: 	module Test2 extends EvalVar, EvalExpr
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A0] & {Add#A :> ?A1 <: ?A0} | Mul[?A2] & {Mul#A :> ?A3 <: ?A2} | Numb | Var`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type `??A` does not contain member `Add#A`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.488: 	module Test2 extends EvalVar, EvalExpr
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A0] & {Add#A :> ?A1 <: ?A0} | Mul[?A2] & {Mul#A :> ?A3 <: ?A2} | Numb | Var`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.488: 	module Test2 extends EvalVar, EvalExpr
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` is not an instance of type `Object`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.417: 	  if v is
//│ ║         	     ^^^^
//│ ║  l.418: 	    Var then v
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.419: 	    Numb then v
//│ ║         	^^^^^^^^^^^^^^^
//│ ║  l.420: 	    Add(l, r) then Add(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.421: 	    Mul(l, r) then Mul(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ module Test2 {
//│   fun eval: forall 'a. (Cons[anything] | Nil, 'a & (Add['A] | Mul['A0] | Numb | Var)) -> (Numb | Var | error | ??A & 'A | ??A0 & 'A0 | 'a)
//│ }

Test2.eval(Nil, Var("a"))
//│ Numb | Var | error
//│ res
//│     = Var {}

Test2.eval(Cons(["c", Abs("d", Var("d"))], Nil), Var("a"))
//│ Numb | Var | error
//│ res
//│     = Var {}

Test2.eval(Cons(["a", Numb(1)], Nil), Var("a"))
//│ Numb | Var | error
//│ res
//│     = Var {}

// * This expected error shows that Test2 does not handle Abs expression inputs
:e
Test2.eval(Cons(["c", Abs("d", Var("d"))], Nil), Abs("a", Var("a")))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.634: 	Test2.eval(Cons(["c", Abs("d", Var("d"))], Nil), Abs("a", Var("a")))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Abs[?A]` does not match type `Add[?A0] | Mul[?A1] | Numb | Var`
//│ ║  l.634: 	Test2.eval(Cons(["c", Abs("d", Var("d"))], Nil), Abs("a", Var("a")))
//│ ║         	                                                 ^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ Abs[Var] | Numb | Var | error
//│ res
//│ Runtime error:
//│   Error: non-exhaustive case expression

Test2.eval(Cons(["a", Abs("d", Var("d"))], Nil), Add(Numb(1), Var("a")))
//│ Add[Numb | Var] | Numb | Var | error
//│ res
//│     = Add {}

module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` does not match type `Add[?A] & {Add#A :> ?A0 <: ?A} | Mul[?A1] & {Mul#A :> ?A2 <: ?A1} | Numb | Var`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `??A` does not contain member `Mul#A`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` does not match type `Add[?A] & {Add#A :> ?A0 <: ?A} | Mul[?A1] & {Mul#A :> ?A2 <: ?A1} | Numb | Var`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `??A` does not contain member `Add#A`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` does not match type `Add[?A] & {Add#A :> ?A0 <: ?A} | Mul[?A1] & {Mul#A :> ?A2 <: ?A1} | Numb | Var`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.417: 	  if v is
//│ ║         	     ^^^^
//│ ║  l.418: 	    Var then v
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.419: 	    Numb then v
//│ ║         	^^^^^^^^^^^^^^^
//│ ║  l.420: 	    Add(l, r) then Add(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.421: 	    Mul(l, r) then Mul(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `App[anything] & ??A` does not contain member `Abs#A`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Abs[?A0] & {Abs#A :> ?A1 <: ?A0} | App[?A2] & {App#A :> ?A3 <: ?A2} | ?a & ~#Abs & ~#App`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type `Abs[anything] & ??A` does not contain member `App#A`
//│ ║  l.50: 	class App[A](s: A, t: A)
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Abs[?A0] & {Abs#A :> ?A1 <: ?A0} | App[?A2] & {App#A :> ?A3 <: ?A2} | ?a & ~#Abs & ~#App`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` is not an instance of type `Object`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.62: 	    if v is
//│ ║        	       ^^^^
//│ ║  l.63: 	      App(t1, t2) then
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.64: 	        let l1 = this.eval(sub, t1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.65: 	        let l2 = this.eval(sub, t2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.66: 	        if t1 is
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.67: 	          Abs(x, t) then this.eval(Cons([x, l2], Nil), t)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.68: 	        else
//│ ║        	^^^^^^^^^^^^
//│ ║  l.69: 	          App(l1, l2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.70: 	      Abs(x, t) then
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.71: 	        let s = gensym()
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.72: 	        Abs(s, this.eval(Cons([x, Var(s)], sub), t))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.73: 	    else
//│ ║        	^^^^^^^^
//│ ║  l.74: 	      super.eval(sub, v)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` does not match type `Add[?A] & {Add#A :> ?A0 <: ?A} | Mul[?A1] & {Mul#A :> ?A2 <: ?A1} | Numb | Var`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `??A` does not contain member `Mul#A`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` does not match type `Add[?A] & {Add#A :> ?A0 <: ?A} | Mul[?A1] & {Mul#A :> ?A2 <: ?A1} | Numb | Var`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `??A` does not contain member `Add#A`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` does not match type `Add[?A] & {Add#A :> ?A0 <: ?A} | Mul[?A1] & {Mul#A :> ?A2 <: ?A1} | Numb | Var`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.417: 	  if v is
//│ ║         	     ^^^^
//│ ║  l.418: 	    Var then v
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.419: 	    Numb then v
//│ ║         	^^^^^^^^^^^^^^^
//│ ║  l.420: 	    Add(l, r) then Add(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.421: 	    Mul(l, r) then Mul(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `App[anything] & ??A` does not contain member `Abs#A`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Abs[?A0] & {Abs#A :> ?A1 <: ?A0} | App[?A2] & {App#A :> ?A3 <: ?A2} | ?a & ~#Abs & ~#App`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type `Abs[anything] & ??A` does not contain member `App#A`
//│ ║  l.50: 	class App[A](s: A, t: A)
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Abs[?A0] & {Abs#A :> ?A1 <: ?A0} | App[?A2] & {App#A :> ?A3 <: ?A2} | ?a & ~#Abs & ~#App`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` is not an instance of type `Object`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.62: 	    if v is
//│ ║        	       ^^^^
//│ ║  l.63: 	      App(t1, t2) then
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.64: 	        let l1 = this.eval(sub, t1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.65: 	        let l2 = this.eval(sub, t2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.66: 	        if t1 is
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.67: 	          Abs(x, t) then this.eval(Cons([x, l2], Nil), t)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.68: 	        else
//│ ║        	^^^^^^^^^^^^
//│ ║  l.69: 	          App(l1, l2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.70: 	      Abs(x, t) then
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.71: 	        let s = gensym()
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.72: 	        Abs(s, this.eval(Cons([x, Var(s)], sub), t))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.73: 	    else
//│ ║        	^^^^^^^^
//│ ║  l.74: 	      super.eval(sub, v)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` does not match type `Add[?A] & {Add#A :> ?A0 <: ?A} | Mul[?A1] & {Mul#A :> ?A2 <: ?A1} | Numb | Var`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `??A` does not contain member `Mul#A`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` does not match type `Add[?A] & {Add#A :> ?A0 <: ?A} | Mul[?A1] & {Mul#A :> ?A2 <: ?A1} | Numb | Var`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `??A` does not contain member `Add#A`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` does not match type `Add[?A] & {Add#A :> ?A0 <: ?A} | Mul[?A1] & {Mul#A :> ?A2 <: ?A1} | Numb | Var`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.417: 	  if v is
//│ ║         	     ^^^^
//│ ║  l.418: 	    Var then v
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.419: 	    Numb then v
//│ ║         	^^^^^^^^^^^^^^^
//│ ║  l.420: 	    Add(l, r) then Add(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.421: 	    Mul(l, r) then Mul(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `App[anything] & ??A` does not contain member `Abs#A`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Abs[?A0] & {Abs#A :> ?A1 <: ?A0} | App[?A2] & {App#A :> ?A3 <: ?A2} | ?a & ~#Abs & ~#App`
//│ ║  l.50: 	class App[A](s: A, t: A)
//│ ║        	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type `Abs[anything] & ??A` does not contain member `App#A`
//│ ║  l.50: 	class App[A](s: A, t: A)
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Abs[?A0] & {Abs#A :> ?A1 <: ?A0} | App[?A2] & {App#A :> ?A3 <: ?A2} | ?a & ~#Abs & ~#App`
//│ ║  l.50: 	class App[A](s: A, t: A)
//│ ║        	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` is not an instance of type `Object`
//│ ║  l.50: 	class App[A](s: A, t: A)
//│ ║        	                   ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.62: 	    if v is
//│ ║        	       ^^^^
//│ ║  l.63: 	      App(t1, t2) then
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.64: 	        let l1 = this.eval(sub, t1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.65: 	        let l2 = this.eval(sub, t2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.66: 	        if t1 is
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.67: 	          Abs(x, t) then this.eval(Cons([x, l2], Nil), t)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.68: 	        else
//│ ║        	^^^^^^^^^^^^
//│ ║  l.69: 	          App(l1, l2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.70: 	      Abs(x, t) then
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.71: 	        let s = gensym()
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.72: 	        Abs(s, this.eval(Cons([x, Var(s)], sub), t))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.73: 	    else
//│ ║        	^^^^^^^^
//│ ║  l.74: 	      super.eval(sub, v)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` does not match type `Add[?A] & {Add#A :> ?A0 <: ?A} | Mul[?A1] & {Mul#A :> ?A2 <: ?A1} | Numb | Var`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `??A` does not contain member `Mul#A`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` does not match type `Add[?A] & {Add#A :> ?A0 <: ?A} | Mul[?A1] & {Mul#A :> ?A2 <: ?A1} | Numb | Var`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `??A` does not contain member `Add#A`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` does not match type `Add[?A] & {Add#A :> ?A0 <: ?A} | Mul[?A1] & {Mul#A :> ?A2 <: ?A1} | Numb | Var`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.417: 	  if v is
//│ ║         	     ^^^^
//│ ║  l.418: 	    Var then v
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.419: 	    Numb then v
//│ ║         	^^^^^^^^^^^^^^^
//│ ║  l.420: 	    Add(l, r) then Add(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.421: 	    Mul(l, r) then Mul(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `App[anything] & ??A` does not contain member `Abs#A`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Abs[?A0] & {Abs#A :> ?A1 <: ?A0} | App[?A2] & {App#A :> ?A3 <: ?A2} | ?a & ~#Abs & ~#App`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type `Abs[anything] & ??A` does not contain member `App#A`
//│ ║  l.50: 	class App[A](s: A, t: A)
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Abs[?A0] & {Abs#A :> ?A1 <: ?A0} | App[?A2] & {App#A :> ?A3 <: ?A2} | ?a & ~#Abs & ~#App`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` is not an instance of type `Object`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.62: 	    if v is
//│ ║        	       ^^^^
//│ ║  l.63: 	      App(t1, t2) then
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.64: 	        let l1 = this.eval(sub, t1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.65: 	        let l2 = this.eval(sub, t2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.66: 	        if t1 is
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.67: 	          Abs(x, t) then this.eval(Cons([x, l2], Nil), t)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.68: 	        else
//│ ║        	^^^^^^^^^^^^
//│ ║  l.69: 	          App(l1, l2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.70: 	      Abs(x, t) then
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.71: 	        let s = gensym()
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.72: 	        Abs(s, this.eval(Cons([x, Var(s)], sub), t))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.73: 	    else
//│ ║        	^^^^^^^^
//│ ║  l.74: 	      super.eval(sub, v)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` does not match type `Add[?A] & {Add#A :> ?A0 <: ?A} | Mul[?A1] & {Mul#A :> ?A2 <: ?A1} | Numb | Var`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `??A` does not contain member `Mul#A`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` does not match type `Add[?A] & {Add#A :> ?A0 <: ?A} | Mul[?A1] & {Mul#A :> ?A2 <: ?A1} | Numb | Var`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `??A` does not contain member `Add#A`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` does not match type `Add[?A] & {Add#A :> ?A0 <: ?A} | Mul[?A1] & {Mul#A :> ?A2 <: ?A1} | Numb | Var`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `??A & ~#Abs & ~#App` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.417: 	  if v is
//│ ║         	     ^^^^
//│ ║  l.418: 	    Var then v
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.419: 	    Numb then v
//│ ║         	^^^^^^^^^^^^^^^
//│ ║  l.420: 	    Add(l, r) then Add(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.421: 	    Mul(l, r) then Mul(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from wildcard pattern:
//│ ║  l.74: 	      super.eval(sub, v)
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `App[anything] & ??A` does not contain member `Abs#A`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Abs[?A0] & {Abs#A :> ?A1 <: ?A0} | App[?A2] & {App#A :> ?A3 <: ?A2} | ?a & ~#Abs & ~#App`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type `Abs[anything] & ??A` does not contain member `App#A`
//│ ║  l.50: 	class App[A](s: A, t: A)
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Abs[?A0] & {Abs#A :> ?A1 <: ?A0} | App[?A2] & {App#A :> ?A3 <: ?A2} | ?a & ~#Abs & ~#App`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.657: 	module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` is not an instance of type `Object`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.62: 	    if v is
//│ ║        	       ^^^^
//│ ║  l.63: 	      App(t1, t2) then
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.64: 	        let l1 = this.eval(sub, t1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.65: 	        let l2 = this.eval(sub, t2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.66: 	        if t1 is
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.67: 	          Abs(x, t) then this.eval(Cons([x, l2], Nil), t)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.68: 	        else
//│ ║        	^^^^^^^^^^^^
//│ ║  l.69: 	          App(l1, l2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.70: 	      Abs(x, t) then
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.71: 	        let s = gensym()
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.72: 	        Abs(s, this.eval(Cons([x, Var(s)], sub), t))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.73: 	    else
//│ ║        	^^^^^^^^
//│ ║  l.74: 	      super.eval(sub, v)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.62: 	    if v is
//│ ╙──      	       ^
//│ module Test3 {
//│   fun eval: (Cons[anything] | Nil, Abs[anything] | App[anything] | 'a & (Add[anything] | Mul[anything] | Numb | Var)) -> (??A & ~#Abs & ~#App | ??A0 & ~#Abs & ~#App | ??A1 & ~#Abs & ~#App | ??A2 & ~#Abs & ~#App | ??A3 & ~#Abs & ~#App | 'a)
//│ }
//│ where
//│   'a :> Abs['a] | App['a] | Numb | Var | error | ??A & ~#Abs & ~#App | ??A0 & ~#Abs & ~#App | ??A1 & ~#Abs & ~#App | ??A2 & ~#Abs & ~#App | ??A3 & ~#Abs & ~#App

Test3.eval(Cons(["c", Abs("d", Var("d"))], Nil), Abs("a", Var("a")))
//│ ??A & ~#Abs & ~#App | ??A0 & ~#Abs & ~#App | ??A1 & ~#Abs & ~#App | ??A2 & ~#Abs & ~#App | ??A3 & ~#Abs & ~#App | 'a
//│   where
//│     'a :> Abs['a] | App['a] | Numb | Var | error | ??A & ~#Abs & ~#App | ??A0 & ~#Abs & ~#App | ??A1 & ~#Abs & ~#App | ??A2 & ~#Abs & ~#App | ??A3 & ~#Abs & ~#App
//│ res
//│     = Abs {}

Test3.eval(Cons(["c", Abs("d", Var("d"))], Nil), App(Abs("a", Var("a")), Add(Numb(1), Var("c"))))
//│ ??A & ~#Abs & ~#App | ??A0 & ~#Abs & ~#App | ??A1 & ~#Abs & ~#App | ??A2 & ~#Abs & ~#App | ??A3 & ~#Abs & ~#App | 'a
//│   where
//│     'a :> Abs['a] | App['a] | Numb | Var | error | ??A & ~#Abs & ~#App | ??A0 & ~#Abs & ~#App | ??A1 & ~#Abs & ~#App | ??A2 & ~#Abs & ~#App | ??A3 & ~#Abs & ~#App
//│ res
//│     = Var {}

// * Incorrect version, for regression testing – EvalLambda should be mixed in after EvalExpr
module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A] & {Add#A :> ?A0 <: ?A} | Mul[?A1] & {Mul#A :> ?A2 <: ?A1} | Numb | Var`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type `??A` does not contain member `Mul#A`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A] & {Add#A :> ?A0 <: ?A} | Mul[?A1] & {Mul#A :> ?A2 <: ?A1} | Numb | Var`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type `??A` does not contain member `Add#A`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A0] & {Add#A :> ?A1 <: ?A0} | Mul[?A2] & {Mul#A :> ?A3 <: ?A2} | Numb | Var`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` is not an instance of type `Object`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.417: 	  if v is
//│ ║         	     ^^^^
//│ ║  l.418: 	    Var then v
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.419: 	    Numb then v
//│ ║         	^^^^^^^^^^^^^^^
//│ ║  l.420: 	    Add(l, r) then Add(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.421: 	    Mul(l, r) then Mul(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A0] & {Add#A :> ?A1 <: ?A0} | Mul[?A2] & {Mul#A :> ?A3 <: ?A2} | Numb | Var`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type `??A` does not contain member `Mul#A`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A0] & {Add#A :> ?A1 <: ?A0} | Mul[?A2] & {Mul#A :> ?A3 <: ?A2} | Numb | Var`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type `??A` does not contain member `Add#A`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A0] & {Add#A :> ?A1 <: ?A0} | Mul[?A2] & {Mul#A :> ?A3 <: ?A2} | Numb | Var`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` is not an instance of type `Object`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ║         	                   ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.417: 	  if v is
//│ ║         	     ^^^^
//│ ║  l.418: 	    Var then v
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.419: 	    Numb then v
//│ ║         	^^^^^^^^^^^^^^^
//│ ║  l.420: 	    Add(l, r) then Add(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.421: 	    Mul(l, r) then Mul(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A0] & {Add#A :> ?A1 <: ?A0} | Mul[?A2] & {Mul#A :> ?A3 <: ?A2} | Numb | Var`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type `??A` does not contain member `Mul#A`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A0] & {Add#A :> ?A1 <: ?A0} | Mul[?A2] & {Mul#A :> ?A3 <: ?A2} | Numb | Var`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type `??A` does not contain member `Add#A`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A0] & {Add#A :> ?A1 <: ?A0} | Mul[?A2] & {Mul#A :> ?A3 <: ?A2} | Numb | Var`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` is not an instance of type `Object`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.417: 	  if v is
//│ ║         	     ^^^^
//│ ║  l.418: 	    Var then v
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.419: 	    Numb then v
//│ ║         	^^^^^^^^^^^^^^^
//│ ║  l.420: 	    Add(l, r) then Add(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.421: 	    Mul(l, r) then Mul(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A0] & {Add#A :> ?A1 <: ?A0} | Mul[?A2] & {Mul#A :> ?A3 <: ?A2} | Numb | Var`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type `??A` does not contain member `Mul#A`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A0] & {Add#A :> ?A1 <: ?A0} | Mul[?A2] & {Mul#A :> ?A3 <: ?A2} | Numb | Var`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type `??A` does not contain member `Add#A`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A0] & {Add#A :> ?A1 <: ?A0} | Mul[?A2] & {Mul#A :> ?A3 <: ?A2} | Numb | Var`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` is not an instance of type `Object`
//│ ║  l.49: 	class Abs[A](x: Str, t: A)
//│ ║        	                     ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.417: 	  if v is
//│ ║         	     ^^^^
//│ ║  l.418: 	    Var then v
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.419: 	    Numb then v
//│ ║         	^^^^^^^^^^^^^^^
//│ ║  l.420: 	    Add(l, r) then Add(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.421: 	    Mul(l, r) then Mul(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A0] & {Add#A :> ?A1 <: ?A0} | Mul[?A2] & {Mul#A :> ?A3 <: ?A2} | Numb | Var`
//│ ║  l.50: 	class App[A](s: A, t: A)
//│ ║        	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type `??A` does not contain member `Mul#A`
//│ ║  l.411: 	class Mul[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A0] & {Add#A :> ?A1 <: ?A0} | Mul[?A2] & {Mul#A :> ?A3 <: ?A2} | Numb | Var`
//│ ║  l.50: 	class App[A](s: A, t: A)
//│ ║        	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type `??A` does not contain member `Add#A`
//│ ║  l.410: 	class Add[A](l: A, r: A)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` does not match type `Add[?A0] & {Add#A :> ?A1 <: ?A0} | Mul[?A2] & {Mul#A :> ?A3 <: ?A2} | Numb | Var`
//│ ║  l.50: 	class App[A](s: A, t: A)
//│ ║        	                   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1249: 	module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `??A & ?A` is not an instance of type `Object`
//│ ║  l.50: 	class App[A](s: A, t: A)
//│ ║        	                   ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.417: 	  if v is
//│ ║         	     ^^^^
//│ ║  l.418: 	    Var then v
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.419: 	    Numb then v
//│ ║         	^^^^^^^^^^^^^^^
//│ ║  l.420: 	    Add(l, r) then Add(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.421: 	    Mul(l, r) then Mul(f(l), f(r))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ module Test3 {
//│   fun eval: (Cons[anything] | Nil, 'a & (Add['A] | Mul['A0] | Numb | Var)) -> (??A & ??A0 | ??A1 & 'A | ??A2 & 'A0 | 'a)
//│ }
//│ where
//│   'a :> Abs['a] | App['a] | Var | error | ??A & ??A0 | ??A2 & (error | 'A0) | ??A1 & (error | 'A) | Numb

// * Because EvalExpr does not dispatch lambdas to super and map_expr only
// * handles exprs
:e
Test3.eval(Cons(["c", Abs("d", Var("d"))], Nil), Abs("a", Var("a")))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1569: 	Test3.eval(Cons(["c", Abs("d", Var("d"))], Nil), Abs("a", Var("a")))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Abs[?A]` does not match type `Add[?A0] | Mul[?A1] | Numb | Var`
//│ ║  l.1569: 	Test3.eval(Cons(["c", Abs("d", Var("d"))], Nil), Abs("a", Var("a")))
//│ ║          	                                                 ^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.417: 	  if v is
//│ ║         	     ^
//│ ╟── from reference:
//│ ║  l.427: 	    let vv = map_expr(eta, v)
//│ ╙──       	                           ^
//│ ??A & ??A0 | 'a
//│   where
//│     'a :> Abs['a] | App['a] | Var | error | Abs[Var] | Numb | error & ??A1 | ??A & ??A0
//│ res
//│ Runtime error:
//│   Error: non-exhaustive case expression

