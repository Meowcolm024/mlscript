:NewDefs


// * Adapted example from Compositional Embeddings of Domain-Specific Languages (OOPSLA 2022)


// ******************* Initial System *******************

class Vector(val x: Int, val y: Int)
//│ class Vector(x: Int, y: Int)

class Circle(radius: Int)
class Outside[out Region](a: Region)
class Union[out Region](a: Region, b: Region)
class Intersect[out Region](a: Region, b: Region)
class Translate[out Region](v: Vector, a: Region)
//│ class Circle(radius: Int)
//│ class Outside[Region](a: Region)
//│ class Union[Region](a: Region, b: Region)
//│ class Intersect[Region](a: Region, b: Region)
//│ class Translate[Region](v: Vector, a: Region)

type BaseLang[T] = Circle | Intersect[T] | Union[T] | Outside[T] | Translate[T]
//│ type BaseLang[T] = Circle | Intersect[T] | Outside[T] | Translate[T] | Union[T]

mixin SizeBase {
  fun size(r) =
    if r is
      Circle(_) then 1
      Outside(a) then this.size(a) + 1
      Union(a, b) then this.size(a) + this.size(b) + 1
      Intersect(a, b) then this.size(a) + this.size(b) + 1
      Translate(_, a) then this.size(a) + 1
}
//│ mixin SizeBase() {
//│   this: {
//│     size: (??Region & 'Region | ??Region0 & 'Region0 | ??Region1 & 'Region1 | ??Region2 & 'Region2) -> Int
//│   }
//│   fun size: (Circle | Intersect['Region] | Outside['Region1] | Translate['Region0] | Union['Region2]) -> Int
//│ }

// ******************* Linguistic Reuse and Meta-Language Optimizations *******************

fun round(n: Num): Int = 0
//│ fun round: (n: Num) -> Int

fun go(x, offset) =
  if x is 0 then Circle(1)
  else
    let shared = go(x - 1, round(offset / 2))
    Union(Translate(Vector(0 - offset, 0), shared), Translate(Vector(offset, 0), shared))
//│ fun go: forall 'Region. (0 | Int & ~0, Int) -> 'Region
//│   where
//│     'Region :> Circle | Union[Translate['Region]]

// * Note that first-class polymorphism manages (correctly) to preserve the universal quantification
let circles = go(2, 1024)
//│ let circles: forall 'Region. 'Region
//│   where
//│     'Region :> Circle | Union[Translate['Region]]
//│ circles
//│         = Union {}

// ******************* Adding More Language Constructs *******************

class Univ()
class Empty()
class Scale[out Region](v: Vector, a: Region)
//│ class Univ()
//│ class Empty()
//│ class Scale[Region](v: Vector, a: Region)

type ExtLang[T] = Univ | Empty | Scale[T]
//│ type ExtLang[T] = Empty | Scale[T] | Univ

mixin SizeExt {
  fun size(a) =
    if a is
      Univ then 1
      Empty then 1
      Scale(_, b) then this.size(b) + 1
    else super.size(a)
}
//│ mixin SizeExt() {
//│   super: {size: 'a -> 'b}
//│   this: {size: (??Region & 'Region) -> Int}
//│   fun size: (Empty | Object & 'a & ~#Empty & ~#Scale & ~#Univ | Scale['Region] | Univ) -> (Int | 'b)
//│ }

type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]

module TestSize extends SizeBase, SizeExt {
  fun size: RegionLang -> Int
}
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.93: 	module TestSize extends SizeBase, SizeExt {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  fun size: RegionLang -> Int
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.95: 	}
//│ ║        	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ║        	                                   ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.94: 	  fun size: RegionLang -> Int
//│ ╙──      	            ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.93: 	module TestSize extends SizeBase, SizeExt {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  fun size: RegionLang -> Int
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.95: 	}
//│ ║        	^
//│ ╟── expression of type `??Region & ~#Empty & ~#Scale & ~#Univ` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.28: 	    if r is
//│ ║        	       ^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.93: 	module TestSize extends SizeBase, SizeExt {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  fun size: RegionLang -> Int
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.95: 	}
//│ ║        	^
//│ ╟── expression of type `??Region & ~#Empty & ~#Scale & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.28: 	    if r is
//│ ║        	       ^^^^
//│ ║  l.29: 	      Circle(_) then 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.30: 	      Outside(a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.31: 	      Union(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.32: 	      Intersect(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.33: 	      Translate(_, a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `Empty & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.93: 	module TestSize extends SizeBase, SizeExt {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  fun size: RegionLang -> Int
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.95: 	}
//│ ║        	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ║        	                                   ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.78: 	    if a is
//│ ║        	       ^^^^
//│ ║  l.79: 	      Univ then 1
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ║  l.80: 	      Empty then 1
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.81: 	      Scale(_, b) then this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.82: 	    else super.size(a)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    if a is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.93: 	module TestSize extends SizeBase, SizeExt {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  fun size: RegionLang -> Int
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.95: 	}
//│ ║        	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.28: 	    if r is
//│ ║        	       ^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.93: 	module TestSize extends SizeBase, SizeExt {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  fun size: RegionLang -> Int
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.95: 	}
//│ ║        	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.28: 	    if r is
//│ ║        	       ^^^^
//│ ║  l.29: 	      Circle(_) then 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.30: 	      Outside(a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.31: 	      Union(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.32: 	      Intersect(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.33: 	      Translate(_, a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.93: 	module TestSize extends SizeBase, SizeExt {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  fun size: RegionLang -> Int
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.95: 	}
//│ ║        	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.78: 	    if a is
//│ ║        	       ^^^^
//│ ║  l.79: 	      Univ then 1
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ║  l.80: 	      Empty then 1
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.81: 	      Scale(_, b) then this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.82: 	    else super.size(a)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    if a is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.93: 	module TestSize extends SizeBase, SizeExt {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  fun size: RegionLang -> Int
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.95: 	}
//│ ║        	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.28: 	    if r is
//│ ║        	       ^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.93: 	module TestSize extends SizeBase, SizeExt {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  fun size: RegionLang -> Int
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.95: 	}
//│ ║        	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.28: 	    if r is
//│ ║        	       ^^^^
//│ ║  l.29: 	      Circle(_) then 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.30: 	      Outside(a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.31: 	      Union(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.32: 	      Intersect(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.33: 	      Translate(_, a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.93: 	module TestSize extends SizeBase, SizeExt {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  fun size: RegionLang -> Int
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.95: 	}
//│ ║        	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.78: 	    if a is
//│ ║        	       ^^^^
//│ ║  l.79: 	      Univ then 1
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ║  l.80: 	      Empty then 1
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.81: 	      Scale(_, b) then this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.82: 	    else super.size(a)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    if a is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.93: 	module TestSize extends SizeBase, SizeExt {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  fun size: RegionLang -> Int
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.95: 	}
//│ ║        	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.28: 	    if r is
//│ ║        	       ^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.93: 	module TestSize extends SizeBase, SizeExt {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  fun size: RegionLang -> Int
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.95: 	}
//│ ║        	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.28: 	    if r is
//│ ║        	       ^^^^
//│ ║  l.29: 	      Circle(_) then 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.30: 	      Outside(a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.31: 	      Union(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.32: 	      Intersect(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.33: 	      Translate(_, a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.93: 	module TestSize extends SizeBase, SizeExt {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  fun size: RegionLang -> Int
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.95: 	}
//│ ║        	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.78: 	    if a is
//│ ║        	       ^^^^
//│ ║  l.79: 	      Univ then 1
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ║  l.80: 	      Empty then 1
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.81: 	      Scale(_, b) then this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.82: 	    else super.size(a)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    if a is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.93: 	module TestSize extends SizeBase, SizeExt {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  fun size: RegionLang -> Int
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.95: 	}
//│ ║        	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.28: 	    if r is
//│ ║        	       ^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.93: 	module TestSize extends SizeBase, SizeExt {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  fun size: RegionLang -> Int
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.95: 	}
//│ ║        	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.28: 	    if r is
//│ ║        	       ^^^^
//│ ║  l.29: 	      Circle(_) then 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.30: 	      Outside(a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.31: 	      Union(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.32: 	      Intersect(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.33: 	      Translate(_, a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.93: 	module TestSize extends SizeBase, SizeExt {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.94: 	  fun size: RegionLang -> Int
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.95: 	}
//│ ║        	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.78: 	    if a is
//│ ║        	       ^^^^
//│ ║  l.79: 	      Univ then 1
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ║  l.80: 	      Empty then 1
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.81: 	      Scale(_, b) then this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.82: 	    else super.size(a)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    if a is
//│ ╙──      	       ^
//│ module TestSize {
//│   fun size: RegionLang -> Int
//│ }

TestSize.size(Empty())
//│ Int
//│ res
//│     = 1

TestSize.size(circles)
//│ Int
//│ res
//│     = 13

TestSize.size(Scale(Vector(1, 1), circles))
//│ Int
//│ res
//│     = 14

// ******************* Adding a New Interpretation *******************
// a stupid power (Int ** Int) implementation
fun pow(x, a) =
  if a is 0 then 1
  else x * pow(x, a - 1)
//│ fun pow: (Int, 0 | Int & ~0) -> Int

mixin Contains {
  fun contains(a, p) =
    if a is
      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
      Outside(a) then not (this.contains(a, p))
      Union(lhs, rhs) then this.contains(lhs, p) || this.contains(rhs, p)
      Intersect(lhs, rhs) then this.contains(lhs, p) && this.contains(rhs, p)
      Translate(v, a) then this.contains(a, Vector(p.x - v.x, p.y - v.y))
}
//│ mixin Contains() {
//│   this: {
//│     contains: (??Region & 'Region | ??Region0 & 'Region0 | ??Region1 & 'Region1, 'a) -> Bool & (??Region2 & 'Region2, Vector) -> 'b
//│   }
//│   fun contains: (Circle | Intersect['Region1] | Outside['Region] | Translate['Region2] | Union['Region0], {x: Int, y: Int} & 'a) -> (Bool | 'b)
//│ }

type BaseRegionLang = BaseLang[BaseRegionLang]
//│ type BaseRegionLang = BaseLang[BaseRegionLang]

module TestContains extends Contains {
  fun contains: (BaseRegionLang, Vector) -> Bool
}
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.492: 	module TestContains extends Contains {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.493: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.494: 	}
//│ ║         	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `Circle | Intersect[BaseRegionLang] | Outside[BaseRegionLang] | Translate[BaseRegionLang] | Union[BaseRegionLang]`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.23: 	type BaseLang[T] = Circle | Intersect[T] | Union[T] | Outside[T] | Translate[T]
//│ ║        	                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.493: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ╙──       	                 ^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.492: 	module TestContains extends Contains {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.493: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.494: 	}
//│ ║         	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `Circle | Intersect[?Region0] | Outside[?Region1] | Translate[?Region] | Union[?Region2]`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.492: 	module TestContains extends Contains {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.493: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.494: 	}
//│ ║         	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.475: 	    if a is
//│ ║         	       ^^^^
//│ ║  l.476: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.477: 	      Outside(a) then not (this.contains(a, p))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.478: 	      Union(lhs, rhs) then this.contains(lhs, p) || this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.479: 	      Intersect(lhs, rhs) then this.contains(lhs, p) && this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.480: 	      Translate(v, a) then this.contains(a, Vector(p.x - v.x, p.y - v.y))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.492: 	module TestContains extends Contains {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.493: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.494: 	}
//│ ║         	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `Circle | Intersect[BaseRegionLang] | Outside[BaseRegionLang] | Translate[BaseRegionLang] | Union[BaseRegionLang]`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.23: 	type BaseLang[T] = Circle | Intersect[T] | Union[T] | Outside[T] | Translate[T]
//│ ║        	                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.493: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ╙──       	                 ^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.492: 	module TestContains extends Contains {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.493: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.494: 	}
//│ ║         	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `Circle | Intersect[?Region0] | Outside[?Region1] | Translate[?Region2] | Union[?Region3]`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.492: 	module TestContains extends Contains {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.493: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.494: 	}
//│ ║         	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.475: 	    if a is
//│ ║         	       ^^^^
//│ ║  l.476: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.477: 	      Outside(a) then not (this.contains(a, p))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.478: 	      Union(lhs, rhs) then this.contains(lhs, p) || this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.479: 	      Intersect(lhs, rhs) then this.contains(lhs, p) && this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.480: 	      Translate(v, a) then this.contains(a, Vector(p.x - v.x, p.y - v.y))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.492: 	module TestContains extends Contains {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.493: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.494: 	}
//│ ║         	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.492: 	module TestContains extends Contains {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.493: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.494: 	}
//│ ║         	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.475: 	    if a is
//│ ║         	       ^^^^
//│ ║  l.476: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.477: 	      Outside(a) then not (this.contains(a, p))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.478: 	      Union(lhs, rhs) then this.contains(lhs, p) || this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.479: 	      Intersect(lhs, rhs) then this.contains(lhs, p) && this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.480: 	      Translate(v, a) then this.contains(a, Vector(p.x - v.x, p.y - v.y))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.492: 	module TestContains extends Contains {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.493: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.494: 	}
//│ ║         	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.492: 	module TestContains extends Contains {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.493: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.494: 	}
//│ ║         	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.475: 	    if a is
//│ ║         	       ^^^^
//│ ║  l.476: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.477: 	      Outside(a) then not (this.contains(a, p))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.478: 	      Union(lhs, rhs) then this.contains(lhs, p) || this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.479: 	      Intersect(lhs, rhs) then this.contains(lhs, p) && this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.480: 	      Translate(v, a) then this.contains(a, Vector(p.x - v.x, p.y - v.y))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.492: 	module TestContains extends Contains {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.493: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.494: 	}
//│ ║         	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.492: 	module TestContains extends Contains {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.493: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.494: 	}
//│ ║         	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.475: 	    if a is
//│ ║         	       ^^^^
//│ ║  l.476: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.477: 	      Outside(a) then not (this.contains(a, p))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.478: 	      Union(lhs, rhs) then this.contains(lhs, p) || this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.479: 	      Intersect(lhs, rhs) then this.contains(lhs, p) && this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.480: 	      Translate(v, a) then this.contains(a, Vector(p.x - v.x, p.y - v.y))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ module TestContains {
//│   fun contains: (BaseRegionLang, Vector) -> Bool
//│ }

TestContains.contains(Translate(Vector(0, 0), Circle(1)), Vector(0, 0))
//│ Bool
//│ res
//│     = true

TestContains.contains(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)), Vector(0, 0))
//│ Bool
//│ res
//│     = true

TestContains.contains(circles, Vector(0, 0))
//│ Bool
//│ res
//│     = false

// ******************* Dependencies, Complex Interpretations, and Domain-Specific Optimizations *******************

fun toString(a: Int): Str = "foo"
fun concat(a: Str, b: Str): Str = a
//│ fun toString: (a: Int) -> Str
//│ fun concat: (a: Str, b: Str) -> Str

mixin Text {
  fun text(e) =
    if e is
      Circle(r) then concat("a circular region of radius ", toString(r))
      Outside(a) then concat("outside a region of size ", toString(this.size(a)))
      Union then concat("the union of two regions of size ", toString(this.size(e)))
      Intersect then concat("the intersection of two regions of size ", toString(this.size(e)))
      Translate then concat("a translated region of size ", toString(this.size(e)))
}
//│ mixin Text() {
//│   this: {
//│     size: (Intersect[??Region & 'Region] | Translate[??Region0 & 'Region0] | Union[??Region1 & 'Region1] | ??Region2 & 'Region2) -> Int
//│   }
//│   fun text: (Circle | Intersect['Region] | Outside['Region2] | Translate['Region0] | Union['Region1]) -> Str
//│ }

:e
module SizeText extends Text
//│ ╔══[ERROR] Type `#SizeText & {text: ?a -> (?b | ?c | ?d | ?e | ?f)}` does not contain member `size`
//│ ║  l.791: 	      Translate then concat("a translated region of size ", toString(this.size(e)))
//│ ╙──       	                                                                         ^^^^^
//│ ╔══[ERROR] Type `#SizeText & {text: ?a -> (?b | ?c | ?d | ?e | ?f)}` does not contain member `size`
//│ ║  l.790: 	      Intersect then concat("the intersection of two regions of size ", toString(this.size(e)))
//│ ╙──       	                                                                                     ^^^^^
//│ ╔══[ERROR] Type `#SizeText & {text: ?a -> (?b | ?c | ?d | ?e | ?f)}` does not contain member `size`
//│ ║  l.789: 	      Union then concat("the union of two regions of size ", toString(this.size(e)))
//│ ╙──       	                                                                          ^^^^^
//│ ╔══[ERROR] Type `#SizeText & {text: ?a -> (?b | ?c | ?d | ?e | ?f)}` does not contain member `size`
//│ ║  l.788: 	      Outside(a) then concat("outside a region of size ", toString(this.size(a)))
//│ ╙──       	                                                                       ^^^^^
//│ module SizeText {
//│   fun text: (Circle | Intersect[anything] | Outside[anything] | Translate[anything] | Union[anything]) -> Str
//│ }

// * Note: this inferred type got *much worse* after this commit (field access type refinement)
module SizeText extends SizeBase, Text {
  fun size: BaseRegionLang -> Int
  fun text: BaseRegionLang -> Str
}
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.819: 	module SizeText extends SizeBase, Text {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.820: 	  fun size: BaseRegionLang -> Int
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.821: 	  fun text: BaseRegionLang -> Str
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.822: 	}
//│ ║         	^
//│ ╟── expression of type `??Region & ?Region` does not match type `Circle | Intersect[BaseRegionLang] | Outside[BaseRegionLang] | Translate[BaseRegionLang] | Union[BaseRegionLang]`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.23: 	type BaseLang[T] = Circle | Intersect[T] | Union[T] | Outside[T] | Translate[T]
//│ ║        	                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.489: 	type BaseRegionLang = BaseLang[BaseRegionLang]
//│ ╙──       	                               ^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.819: 	module SizeText extends SizeBase, Text {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.820: 	  fun size: BaseRegionLang -> Int
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.821: 	  fun text: BaseRegionLang -> Str
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.822: 	}
//│ ║         	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.28: 	    if r is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.819: 	module SizeText extends SizeBase, Text {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.820: 	  fun size: BaseRegionLang -> Int
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.821: 	  fun text: BaseRegionLang -> Str
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.822: 	}
//│ ║         	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.28: 	    if r is
//│ ║        	       ^^^^
//│ ║  l.29: 	      Circle(_) then 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.30: 	      Outside(a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.31: 	      Union(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.32: 	      Intersect(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.33: 	      Translate(_, a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.28: 	    if r is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.819: 	module SizeText extends SizeBase, Text {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.820: 	  fun size: BaseRegionLang -> Int
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.821: 	  fun text: BaseRegionLang -> Str
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.822: 	}
//│ ║         	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.28: 	    if r is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.819: 	module SizeText extends SizeBase, Text {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.820: 	  fun size: BaseRegionLang -> Int
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.821: 	  fun text: BaseRegionLang -> Str
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.822: 	}
//│ ║         	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.28: 	    if r is
//│ ║        	       ^^^^
//│ ║  l.29: 	      Circle(_) then 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.30: 	      Outside(a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.31: 	      Union(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.32: 	      Intersect(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.33: 	      Translate(_, a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.28: 	    if r is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.819: 	module SizeText extends SizeBase, Text {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.820: 	  fun size: BaseRegionLang -> Int
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.821: 	  fun text: BaseRegionLang -> Str
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.822: 	}
//│ ║         	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.28: 	    if r is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.819: 	module SizeText extends SizeBase, Text {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.820: 	  fun size: BaseRegionLang -> Int
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.821: 	  fun text: BaseRegionLang -> Str
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.822: 	}
//│ ║         	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.28: 	    if r is
//│ ║        	       ^^^^
//│ ║  l.29: 	      Circle(_) then 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.30: 	      Outside(a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.31: 	      Union(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.32: 	      Intersect(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.33: 	      Translate(_, a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.28: 	    if r is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.819: 	module SizeText extends SizeBase, Text {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.820: 	  fun size: BaseRegionLang -> Int
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.821: 	  fun text: BaseRegionLang -> Str
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.822: 	}
//│ ║         	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.28: 	    if r is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.819: 	module SizeText extends SizeBase, Text {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.820: 	  fun size: BaseRegionLang -> Int
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.821: 	  fun text: BaseRegionLang -> Str
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.822: 	}
//│ ║         	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.28: 	    if r is
//│ ║        	       ^^^^
//│ ║  l.29: 	      Circle(_) then 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.30: 	      Outside(a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.31: 	      Union(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.32: 	      Intersect(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.33: 	      Translate(_, a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.28: 	    if r is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.819: 	module SizeText extends SizeBase, Text {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.820: 	  fun size: BaseRegionLang -> Int
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.821: 	  fun text: BaseRegionLang -> Str
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.822: 	}
//│ ║         	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.28: 	    if r is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.819: 	module SizeText extends SizeBase, Text {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.820: 	  fun size: BaseRegionLang -> Int
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.821: 	  fun text: BaseRegionLang -> Str
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.822: 	}
//│ ║         	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.28: 	    if r is
//│ ║        	       ^^^^
//│ ║  l.29: 	      Circle(_) then 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.30: 	      Outside(a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.31: 	      Union(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.32: 	      Intersect(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.33: 	      Translate(_, a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.28: 	    if r is
//│ ╙──      	       ^
//│ module SizeText {
//│   fun size: BaseRegionLang -> Int
//│   fun text: BaseRegionLang -> Str
//│ }

SizeText.text(circles)
//│ Str
//│ res
//│     = 'the union of two regions of size '

SizeText.size(circles)
//│ Int
//│ res
//│     = 13

SizeText.text(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)))
//│ Str
//│ res
//│     = 'the intersection of two regions of size '

SizeText.size(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)))
//│ Int
//│ res
//│     = 4

mixin IsUniv {
  fun isUniv(e) =
    if e is
      Univ then true
      Outside(a) then this.isEmpty(a)
      Union(a, b) then this.isUniv(a) || this.isUniv(b)
      Intersect(a, b) then this.isUniv(a) && this.isUniv(b)
      Translate(_, a) then this.isUniv(a)
      Scale(_, a) then this.isUniv(a)
    else false
}
//│ mixin IsUniv() {
//│   this: {
//│     isEmpty: (??Region & 'Region) -> 'a,
//│     isUniv: (??Region0 & 'Region0 | ??Region1 & 'Region1) -> Bool & (??Region2 & 'Region2 | ??Region3 & 'Region3) -> 'a
//│   }
//│   fun isUniv: (Intersect['Region1] | Object & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ | Outside['Region] | Scale['Region3] | Translate['Region2] | Union['Region0] | Univ) -> (Bool | 'a)
//│ }

mixin IsEmpty {
  fun isEmpty(e) =
    if e is
      Univ then true
      Outside(a) then this.isUniv(a)
      Union(a, b) then this.isEmpty(a) || this.isEmpty(b)
      Intersect(a, b) then this.isEmpty(a) && this.isEmpty(b)
      Translate(_, a) then this.isEmpty(a)
      Scale(_, a) then this.isEmpty(a)
    else false
}
//│ mixin IsEmpty() {
//│   this: {
//│     isEmpty: (??Region & 'Region | ??Region0 & 'Region0) -> Bool & (??Region1 & 'Region1 | ??Region2 & 'Region2) -> 'a,
//│     isUniv: (??Region3 & 'Region3) -> 'a
//│   }
//│   fun isEmpty: (Intersect['Region0] | Object & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ | Outside['Region3] | Scale['Region2] | Translate['Region1] | Union['Region] | Univ) -> (Bool | 'a)
//│ }

module IsUnivIsEmpty extends IsUniv, IsEmpty {
  fun isEmpty: RegionLang -> Bool
  fun isUniv: RegionLang -> Bool
}
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1109: 	module IsUnivIsEmpty extends IsUniv, IsEmpty {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1110: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1111: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1112: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ║        	                                   ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.1110: 	  fun isEmpty: RegionLang -> Bool
//│ ╙──        	               ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1109: 	module IsUnivIsEmpty extends IsUniv, IsEmpty {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1110: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1111: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1112: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ║        	                                   ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1092: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1093: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1094: 	      Outside(a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1095: 	      Union(a, b) then this.isEmpty(a) || this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1096: 	      Intersect(a, b) then this.isEmpty(a) && this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1097: 	      Translate(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1098: 	      Scale(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1099: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1092: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1109: 	module IsUnivIsEmpty extends IsUniv, IsEmpty {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1110: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1111: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1112: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.1110: 	  fun isEmpty: RegionLang -> Bool
//│ ╙──        	               ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1109: 	module IsUnivIsEmpty extends IsUniv, IsEmpty {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1110: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1111: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1112: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1092: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1093: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1094: 	      Outside(a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1095: 	      Union(a, b) then this.isEmpty(a) || this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1096: 	      Intersect(a, b) then this.isEmpty(a) && this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1097: 	      Translate(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1098: 	      Scale(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1099: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1092: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1109: 	module IsUnivIsEmpty extends IsUniv, IsEmpty {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1110: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1111: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1112: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.1110: 	  fun isEmpty: RegionLang -> Bool
//│ ╙──        	               ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1109: 	module IsUnivIsEmpty extends IsUniv, IsEmpty {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1110: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1111: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1112: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1092: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1093: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1094: 	      Outside(a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1095: 	      Union(a, b) then this.isEmpty(a) || this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1096: 	      Intersect(a, b) then this.isEmpty(a) && this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1097: 	      Translate(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1098: 	      Scale(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1099: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1092: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1109: 	module IsUnivIsEmpty extends IsUniv, IsEmpty {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1110: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1111: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1112: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1092: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1093: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1094: 	      Outside(a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1095: 	      Union(a, b) then this.isEmpty(a) || this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1096: 	      Intersect(a, b) then this.isEmpty(a) && this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1097: 	      Translate(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1098: 	      Scale(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1099: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1092: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1109: 	module IsUnivIsEmpty extends IsUniv, IsEmpty {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1110: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1111: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1112: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1092: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1093: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1094: 	      Outside(a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1095: 	      Union(a, b) then this.isEmpty(a) || this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1096: 	      Intersect(a, b) then this.isEmpty(a) && this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1097: 	      Translate(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1098: 	      Scale(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1099: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1092: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1109: 	module IsUnivIsEmpty extends IsUniv, IsEmpty {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1110: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1111: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1112: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ║        	                          ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.1111: 	  fun isUniv: RegionLang -> Bool
//│ ╙──        	              ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1109: 	module IsUnivIsEmpty extends IsUniv, IsEmpty {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1110: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1111: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1112: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ║        	                          ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1073: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1074: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1075: 	      Outside(a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1076: 	      Union(a, b) then this.isUniv(a) || this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1077: 	      Intersect(a, b) then this.isUniv(a) && this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1078: 	      Translate(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1079: 	      Scale(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1080: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1073: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1109: 	module IsUnivIsEmpty extends IsUniv, IsEmpty {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1110: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1111: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1112: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1073: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1074: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1075: 	      Outside(a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1076: 	      Union(a, b) then this.isUniv(a) || this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1077: 	      Intersect(a, b) then this.isUniv(a) && this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1078: 	      Translate(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1079: 	      Scale(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1080: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1073: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1109: 	module IsUnivIsEmpty extends IsUniv, IsEmpty {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1110: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1111: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1112: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1073: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1074: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1075: 	      Outside(a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1076: 	      Union(a, b) then this.isUniv(a) || this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1077: 	      Intersect(a, b) then this.isUniv(a) && this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1078: 	      Translate(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1079: 	      Scale(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1080: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1073: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1109: 	module IsUnivIsEmpty extends IsUniv, IsEmpty {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1110: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1111: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1112: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1073: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1074: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1075: 	      Outside(a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1076: 	      Union(a, b) then this.isUniv(a) || this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1077: 	      Intersect(a, b) then this.isUniv(a) && this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1078: 	      Translate(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1079: 	      Scale(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1080: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1073: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1109: 	module IsUnivIsEmpty extends IsUniv, IsEmpty {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1110: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1111: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1112: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1073: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1074: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1075: 	      Outside(a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1076: 	      Union(a, b) then this.isUniv(a) || this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1077: 	      Intersect(a, b) then this.isUniv(a) && this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1078: 	      Translate(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1079: 	      Scale(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1080: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1073: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1109: 	module IsUnivIsEmpty extends IsUniv, IsEmpty {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1110: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1111: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1112: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1092: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1093: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1094: 	      Outside(a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1095: 	      Union(a, b) then this.isEmpty(a) || this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1096: 	      Intersect(a, b) then this.isEmpty(a) && this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1097: 	      Translate(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1098: 	      Scale(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1099: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1092: 	    if e is
//│ ╙──        	       ^
//│ module IsUnivIsEmpty {
//│   fun isEmpty: RegionLang -> Bool
//│   fun isUniv: RegionLang -> Bool
//│ }

module IsUnivIsEmpty extends IsEmpty, IsUniv {
  fun isEmpty: RegionLang -> Bool
  fun isUniv: RegionLang -> Bool
}
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1888: 	module IsUnivIsEmpty extends IsEmpty, IsUniv {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1889: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1890: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1891: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ║        	                                   ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.1890: 	  fun isUniv: RegionLang -> Bool
//│ ╙──        	              ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1888: 	module IsUnivIsEmpty extends IsEmpty, IsUniv {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1889: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1890: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1891: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ║        	                                   ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1073: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1074: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1075: 	      Outside(a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1076: 	      Union(a, b) then this.isUniv(a) || this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1077: 	      Intersect(a, b) then this.isUniv(a) && this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1078: 	      Translate(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1079: 	      Scale(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1080: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1073: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1888: 	module IsUnivIsEmpty extends IsEmpty, IsUniv {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1889: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1890: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1891: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.1890: 	  fun isUniv: RegionLang -> Bool
//│ ╙──        	              ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1888: 	module IsUnivIsEmpty extends IsEmpty, IsUniv {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1889: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1890: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1891: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1073: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1074: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1075: 	      Outside(a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1076: 	      Union(a, b) then this.isUniv(a) || this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1077: 	      Intersect(a, b) then this.isUniv(a) && this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1078: 	      Translate(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1079: 	      Scale(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1080: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1073: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1888: 	module IsUnivIsEmpty extends IsEmpty, IsUniv {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1889: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1890: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1891: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.1890: 	  fun isUniv: RegionLang -> Bool
//│ ╙──        	              ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1888: 	module IsUnivIsEmpty extends IsEmpty, IsUniv {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1889: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1890: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1891: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1073: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1074: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1075: 	      Outside(a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1076: 	      Union(a, b) then this.isUniv(a) || this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1077: 	      Intersect(a, b) then this.isUniv(a) && this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1078: 	      Translate(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1079: 	      Scale(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1080: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1073: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1888: 	module IsUnivIsEmpty extends IsEmpty, IsUniv {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1889: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1890: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1891: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1073: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1074: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1075: 	      Outside(a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1076: 	      Union(a, b) then this.isUniv(a) || this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1077: 	      Intersect(a, b) then this.isUniv(a) && this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1078: 	      Translate(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1079: 	      Scale(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1080: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1073: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1888: 	module IsUnivIsEmpty extends IsEmpty, IsUniv {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1889: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1890: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1891: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1073: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1074: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1075: 	      Outside(a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1076: 	      Union(a, b) then this.isUniv(a) || this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1077: 	      Intersect(a, b) then this.isUniv(a) && this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1078: 	      Translate(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1079: 	      Scale(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1080: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1073: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1888: 	module IsUnivIsEmpty extends IsEmpty, IsUniv {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1889: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1890: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1891: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ║        	                          ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.1889: 	  fun isEmpty: RegionLang -> Bool
//│ ╙──        	               ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1888: 	module IsUnivIsEmpty extends IsEmpty, IsUniv {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1889: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1890: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1891: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ║        	                          ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1092: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1093: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1094: 	      Outside(a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1095: 	      Union(a, b) then this.isEmpty(a) || this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1096: 	      Intersect(a, b) then this.isEmpty(a) && this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1097: 	      Translate(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1098: 	      Scale(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1099: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1092: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1888: 	module IsUnivIsEmpty extends IsEmpty, IsUniv {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1889: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1890: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1891: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1092: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1093: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1094: 	      Outside(a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1095: 	      Union(a, b) then this.isEmpty(a) || this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1096: 	      Intersect(a, b) then this.isEmpty(a) && this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1097: 	      Translate(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1098: 	      Scale(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1099: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1092: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1888: 	module IsUnivIsEmpty extends IsEmpty, IsUniv {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1889: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1890: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1891: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1092: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1093: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1094: 	      Outside(a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1095: 	      Union(a, b) then this.isEmpty(a) || this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1096: 	      Intersect(a, b) then this.isEmpty(a) && this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1097: 	      Translate(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1098: 	      Scale(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1099: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1092: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1888: 	module IsUnivIsEmpty extends IsEmpty, IsUniv {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1889: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1890: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1891: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1092: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1093: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1094: 	      Outside(a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1095: 	      Union(a, b) then this.isEmpty(a) || this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1096: 	      Intersect(a, b) then this.isEmpty(a) && this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1097: 	      Translate(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1098: 	      Scale(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1099: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1092: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1888: 	module IsUnivIsEmpty extends IsEmpty, IsUniv {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1889: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1890: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1891: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1092: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1093: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1094: 	      Outside(a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1095: 	      Union(a, b) then this.isEmpty(a) || this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1096: 	      Intersect(a, b) then this.isEmpty(a) && this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1097: 	      Translate(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1098: 	      Scale(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1099: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1092: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.1888: 	module IsUnivIsEmpty extends IsEmpty, IsUniv {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1889: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1890: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1891: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1073: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1074: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1075: 	      Outside(a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1076: 	      Union(a, b) then this.isUniv(a) || this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1077: 	      Intersect(a, b) then this.isUniv(a) && this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1078: 	      Translate(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1079: 	      Scale(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1080: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1073: 	    if e is
//│ ╙──        	       ^
//│ module IsUnivIsEmpty {
//│   fun isEmpty: RegionLang -> Bool
//│   fun isUniv: RegionLang -> Bool
//│ }

IsUnivIsEmpty.isUniv(circles)
//│ Bool
//│ res
//│     = false

IsUnivIsEmpty.isEmpty(circles)
//│ Bool
//│ res
//│     = false

:e // Expected since the annotation only allows Lang variants
class Foo()
IsUnivIsEmpty.isEmpty(Scale(Vector(1, 2), Intersect(Foo(), circles)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.2679: 	IsUnivIsEmpty.isEmpty(Scale(Vector(1, 2), Intersect(Foo(), circles)))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Foo` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2679: 	IsUnivIsEmpty.isEmpty(Scale(Vector(1, 2), Intersect(Foo(), circles)))
//│ ║          	                                                    ^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ╙──      	                           ^^^^^^^^^^
//│ class Foo()
//│ error | false | true
//│ res
//│     = false

mixin Eliminate {
  fun eliminate(e) =
    if e is
      Outside(Outside(a)) then this.eliminate(a)
      Outside(a) then Outside(this.eliminate(a))
      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
      Translate(v, a) then Translate(v, this.eliminate(a))
      Scale(v, a) then Scale(v, this.eliminate(a))
    else e
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.2699: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `Region & ?Region` is not an instance of type `Object`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ║        	                          ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from application:
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ╙──        	              ^^^^^^^^^^
//│ mixin Eliminate() {
//│   this: {
//│     eliminate: (??Region & ??Region0) -> 'a & (??Region1 & 'Region) -> 'b & (??Region2 & 'Region0) -> 'c & (??Region3 & 'Region1) -> 'd & (??Region4 & 'Region2) -> 'e & (??Region5 & 'Region3) -> 'f
//│   }
//│   fun eliminate: (Intersect['Region1] | Object & 'a & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union | Outside['Region] | Scale['Region3] | Translate['Region2] | Union['Region0]) -> (Intersect['d] | Outside['b] | Scale['f] | Translate['e] | Union['c] | error | 'a)
//│ }

module TestElim extends Eliminate {
  fun eliminate: RegionLang -> RegionLang
}
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.2733: 	module TestElim extends Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2734: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2735: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ║        	                                   ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.2734: 	  fun eliminate: RegionLang -> RegionLang
//│ ╙──        	                 ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.2733: 	module TestElim extends Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2734: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2735: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ║        	                                   ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.2699: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.2699: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.2733: 	module TestElim extends Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2734: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2735: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.2734: 	  fun eliminate: RegionLang -> RegionLang
//│ ╙──        	                 ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.2733: 	module TestElim extends Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2734: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2735: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.2699: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.2699: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.2733: 	module TestElim extends Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2734: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2735: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.2734: 	  fun eliminate: RegionLang -> RegionLang
//│ ╙──        	                 ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.2733: 	module TestElim extends Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2734: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2735: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.2699: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.2699: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.2733: 	module TestElim extends Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2734: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2735: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ║        	                                   ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.2734: 	  fun eliminate: RegionLang -> RegionLang
//│ ╙──        	                 ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.2733: 	module TestElim extends Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2734: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2735: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ║        	                                   ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.2699: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.2699: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.2733: 	module TestElim extends Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2734: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2735: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ║        	                          ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.2734: 	  fun eliminate: RegionLang -> RegionLang
//│ ╙──        	                 ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.2733: 	module TestElim extends Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2734: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2735: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ║        	                          ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.2699: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.2699: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.2733: 	module TestElim extends Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2734: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2735: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ║        	                          ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.2734: 	  fun eliminate: RegionLang -> RegionLang
//│ ╙──        	                 ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.2733: 	module TestElim extends Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2734: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2735: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ║        	                          ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.2699: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.2699: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in definition of method eliminate:
//│ ║  l.2698: 	  fun eliminate(e) =
//│ ║          	      ^^^^^^^^^^^^^^
//│ ║  l.2699: 	    if e is
//│ ║          	^^^^^^^^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── wildcard pattern of type `??Region & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2706: 	    else e
//│ ║          	         ^
//│ ╟── but it flows into application with expected type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	                              ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ╙──      	                           ^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method eliminate:
//│ ║  l.2698: 	  fun eliminate(e) =
//│ ║          	      ^^^^^^^^^^^^^^
//│ ║  l.2699: 	    if e is
//│ ║          	^^^^^^^^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── wildcard pattern of type `??Region & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2706: 	    else e
//│ ║          	         ^
//│ ╟── but it flows into application with expected type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	                              ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ╙──      	                           ^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method eliminate:
//│ ║  l.2698: 	  fun eliminate(e) =
//│ ║          	      ^^^^^^^^^^^^^^
//│ ║  l.2699: 	    if e is
//│ ║          	^^^^^^^^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── wildcard pattern of type `??Region & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2706: 	    else e
//│ ║          	         ^
//│ ╟── but it flows into application with expected type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	                              ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ╙──      	                           ^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method eliminate:
//│ ║  l.2698: 	  fun eliminate(e) =
//│ ║          	      ^^^^^^^^^^^^^^
//│ ║  l.2699: 	    if e is
//│ ║          	^^^^^^^^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── wildcard pattern of type `??Region & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2706: 	    else e
//│ ║          	         ^
//│ ╟── but it flows into application with expected type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	                              ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ╙──      	                           ^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method eliminate:
//│ ║  l.2698: 	  fun eliminate(e) =
//│ ║          	      ^^^^^^^^^^^^^^
//│ ║  l.2699: 	    if e is
//│ ║          	^^^^^^^^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── wildcard pattern of type `??Region & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2706: 	    else e
//│ ║          	         ^
//│ ╟── but it flows into application with expected type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	                              ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ╙──      	                           ^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method eliminate:
//│ ║  l.2698: 	  fun eliminate(e) =
//│ ║          	      ^^^^^^^^^^^^^^
//│ ║  l.2699: 	    if e is
//│ ║          	^^^^^^^^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── wildcard pattern of type `??Region & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2706: 	    else e
//│ ║          	         ^
//│ ╟── but it flows into application with expected type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	                              ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ╙──      	                           ^^^^^^^^^^
//│ module TestElim {
//│   fun eliminate: RegionLang -> RegionLang
//│ }

TestElim.eliminate(Outside(Outside(Univ())))
//│ RegionLang
//│ res
//│     = Univ {}

TestElim.eliminate(circles)
//│ RegionLang
//│ res
//│     = Union {}

fun mk(n) = if n is
  1 then Outside(mk(n))
  2 then Union(mk(n), mk(n))
  3 then Intersect(mk(n), mk(n))
  4 then Translate(Vector(0, 0), mk(n))
  _ then Scale(Vector(0, 0), mk(n))
//│ fun mk: forall 'a. Object -> 'a
//│   where
//│     'a :> Intersect['a] | Outside['a] | Scale['a] | Translate['a] | Union['a]

:re
TestElim.eliminate(mk(100))
//│ RegionLang
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

// *************************************************************************

module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
  fun contains: (BaseRegionLang, Vector) -> Bool
  fun eliminate: RegionLang -> RegionLang
  fun isEmpty: RegionLang -> Bool
  fun isUniv: RegionLang -> Bool
  fun size: RegionLang -> Int
  fun text: BaseRegionLang -> Str
}
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ║        	                                   ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ╙──        	                 ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ║        	                                   ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.2699: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.2699: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ╙──        	                 ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.2699: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.2699: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ╙──        	                 ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.2699: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.2699: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ║        	                                   ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ╙──        	                 ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ║        	                                   ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.2699: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.2699: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ║        	                          ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ╙──        	                 ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ║        	                          ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.2699: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.2699: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ║        	                          ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ╙──        	                 ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ║        	                          ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.2699: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.2699: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ║        	                                   ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ╙──        	               ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ║        	                                   ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1092: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1093: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1094: 	      Outside(a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1095: 	      Union(a, b) then this.isEmpty(a) || this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1096: 	      Intersect(a, b) then this.isEmpty(a) && this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1097: 	      Translate(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1098: 	      Scale(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1099: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1092: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ╙──        	               ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1092: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1093: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1094: 	      Outside(a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1095: 	      Union(a, b) then this.isEmpty(a) || this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1096: 	      Intersect(a, b) then this.isEmpty(a) && this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1097: 	      Translate(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1098: 	      Scale(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1099: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1092: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ╙──        	               ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1092: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1093: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1094: 	      Outside(a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1095: 	      Union(a, b) then this.isEmpty(a) || this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1096: 	      Intersect(a, b) then this.isEmpty(a) && this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1097: 	      Translate(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1098: 	      Scale(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1099: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1092: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1092: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1093: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1094: 	      Outside(a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1095: 	      Union(a, b) then this.isEmpty(a) || this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1096: 	      Intersect(a, b) then this.isEmpty(a) && this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1097: 	      Translate(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1098: 	      Scale(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1099: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1092: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1092: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1093: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1094: 	      Outside(a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1095: 	      Union(a, b) then this.isEmpty(a) || this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1096: 	      Intersect(a, b) then this.isEmpty(a) && this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1097: 	      Translate(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1098: 	      Scale(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1099: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1092: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ║        	                          ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ╙──        	              ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Outside[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `Intersect[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Union[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Translate[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Scale[anything] & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `Univ & ??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ║        	                          ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1073: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1074: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1075: 	      Outside(a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1076: 	      Union(a, b) then this.isUniv(a) || this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1077: 	      Intersect(a, b) then this.isUniv(a) && this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1078: 	      Translate(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1079: 	      Scale(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1080: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1073: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1073: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1074: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1075: 	      Outside(a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1076: 	      Union(a, b) then this.isUniv(a) || this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1077: 	      Intersect(a, b) then this.isUniv(a) && this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1078: 	      Translate(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1079: 	      Scale(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1080: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1073: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1073: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1074: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1075: 	      Outside(a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1076: 	      Union(a, b) then this.isUniv(a) || this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1077: 	      Intersect(a, b) then this.isUniv(a) && this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1078: 	      Translate(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1079: 	      Scale(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1080: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1073: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1073: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1074: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1075: 	      Outside(a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1076: 	      Union(a, b) then this.isUniv(a) || this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1077: 	      Intersect(a, b) then this.isUniv(a) && this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1078: 	      Translate(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1079: 	      Scale(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1080: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1073: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1073: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1074: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1075: 	      Outside(a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1076: 	      Union(a, b) then this.isUniv(a) || this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1077: 	      Intersect(a, b) then this.isUniv(a) && this.isUniv(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1078: 	      Translate(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1079: 	      Scale(_, a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1080: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1073: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.1092: 	    if e is
//│ ║          	       ^^^^
//│ ║  l.1093: 	      Univ then true
//│ ║          	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1094: 	      Outside(a) then this.isUniv(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1095: 	      Union(a, b) then this.isEmpty(a) || this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1096: 	      Intersect(a, b) then this.isEmpty(a) && this.isEmpty(b)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1097: 	      Translate(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1098: 	      Scale(_, a) then this.isEmpty(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.1099: 	    else false
//│ ║          	^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.1092: 	    if e is
//│ ╙──        	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ?Region` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ╙──      	                           ^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Scale#Region`
//│ ║  l.68: 	class Scale[out Region](v: Vector, a: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.28: 	    if r is
//│ ║        	       ^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.28: 	    if r is
//│ ║        	       ^^^^
//│ ║  l.29: 	      Circle(_) then 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.30: 	      Outside(a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.31: 	      Union(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.32: 	      Intersect(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.33: 	      Translate(_, a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.78: 	    if a is
//│ ║        	       ^^^^
//│ ║  l.79: 	      Univ then 1
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ║  l.80: 	      Empty then 1
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.81: 	      Scale(_, b) then this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.82: 	    else super.size(a)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    if a is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `Circle | Intersect[BaseRegionLang] | Outside[BaseRegionLang] | Translate[BaseRegionLang] | Union[BaseRegionLang]`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.23: 	type BaseLang[T] = Circle | Intersect[T] | Union[T] | Outside[T] | Translate[T]
//│ ║        	                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ╙──        	                 ^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `Circle | Intersect[?Region0] | Outside[?Region1] | Translate[?Region] | Union[?Region2]`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.475: 	    if a is
//│ ║         	       ^^^^
//│ ║  l.476: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.477: 	      Outside(a) then not (this.contains(a, p))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.478: 	      Union(lhs, rhs) then this.contains(lhs, p) || this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.479: 	      Intersect(lhs, rhs) then this.contains(lhs, p) && this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.480: 	      Translate(v, a) then this.contains(a, Vector(p.x - v.x, p.y - v.y))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `Circle | Intersect[BaseRegionLang] | Outside[BaseRegionLang] | Translate[BaseRegionLang] | Union[BaseRegionLang]`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.23: 	type BaseLang[T] = Circle | Intersect[T] | Union[T] | Outside[T] | Translate[T]
//│ ║        	                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ╙──        	                 ^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` does not match type `Circle | Intersect[?Region0] | Outside[?Region1] | Translate[?Region2] | Union[?Region3]`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ ╔══[ERROR] Type `??Region` does not contain member `Translate#Region`
//│ ║  l.16: 	class Translate[out Region](v: Vector, a: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Intersect#Region`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ╙──      	                    ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Union#Region`
//│ ║  l.14: 	class Union[out Region](a: Region, b: Region)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type `??Region` does not contain member `Outside#Region`
//│ ║  l.13: 	class Outside[out Region](a: Region)
//│ ╙──      	                  ^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── field selection of type `??Region & ?Region` is not an instance of type `Object`
//│ ║  l.15: 	class Intersect[out Region](a: Region, b: Region)
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.475: 	    if a is
//│ ║         	       ^^^^
//│ ║  l.476: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.477: 	      Outside(a) then not (this.contains(a, p))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.478: 	      Union(lhs, rhs) then this.contains(lhs, p) || this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.479: 	      Intersect(lhs, rhs) then this.contains(lhs, p) && this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.480: 	      Translate(v, a) then this.contains(a, Vector(p.x - v.x, p.y - v.y))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.475: 	    if a is
//│ ║         	       ^^^^
//│ ║  l.476: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.477: 	      Outside(a) then not (this.contains(a, p))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.478: 	      Union(lhs, rhs) then this.contains(lhs, p) || this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.479: 	      Intersect(lhs, rhs) then this.contains(lhs, p) && this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.480: 	      Translate(v, a) then this.contains(a, Vector(p.x - v.x, p.y - v.y))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.475: 	    if a is
//│ ║         	       ^^^^
//│ ║  l.476: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.477: 	      Outside(a) then not (this.contains(a, p))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.478: 	      Union(lhs, rhs) then this.contains(lhs, p) || this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.479: 	      Intersect(lhs, rhs) then this.contains(lhs, p) && this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.480: 	      Translate(v, a) then this.contains(a, Vector(p.x - v.x, p.y - v.y))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Intersect & ~#Outside & ~#Translate & ~#Union` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.475: 	    if a is
//│ ║         	       ^^^^
//│ ║  l.476: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.477: 	      Outside(a) then not (this.contains(a, p))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.478: 	      Union(lhs, rhs) then this.contains(lhs, p) || this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.479: 	      Intersect(lhs, rhs) then this.contains(lhs, p) && this.contains(rhs, p)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.480: 	      Translate(v, a) then this.contains(a, Vector(p.x - v.x, p.y - v.y))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.475: 	    if a is
//│ ╙──       	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.28: 	    if r is
//│ ║        	       ^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.28: 	    if r is
//│ ║        	       ^^^^
//│ ║  l.29: 	      Circle(_) then 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.30: 	      Outside(a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.31: 	      Union(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.32: 	      Intersect(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.33: 	      Translate(_, a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.78: 	    if a is
//│ ║        	       ^^^^
//│ ║  l.79: 	      Univ then 1
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ║  l.80: 	      Empty then 1
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.81: 	      Scale(_, b) then this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.82: 	    else super.size(a)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    if a is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.28: 	    if r is
//│ ║        	       ^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.28: 	    if r is
//│ ║        	       ^^^^
//│ ║  l.29: 	      Circle(_) then 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.30: 	      Outside(a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.31: 	      Union(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.32: 	      Intersect(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.33: 	      Translate(_, a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.78: 	    if a is
//│ ║        	       ^^^^
//│ ║  l.79: 	      Univ then 1
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ║  l.80: 	      Empty then 1
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.81: 	      Scale(_, b) then this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.82: 	    else super.size(a)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    if a is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.28: 	    if r is
//│ ║        	       ^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.28: 	    if r is
//│ ║        	       ^^^^
//│ ║  l.29: 	      Circle(_) then 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.30: 	      Outside(a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.31: 	      Union(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.32: 	      Intersect(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.33: 	      Translate(_, a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.78: 	    if a is
//│ ║        	       ^^^^
//│ ║  l.79: 	      Univ then 1
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ║  l.80: 	      Empty then 1
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.81: 	      Scale(_, b) then this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.82: 	    else super.size(a)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    if a is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.28: 	    if r is
//│ ║        	       ^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.28: 	    if r is
//│ ║        	       ^^^^
//│ ║  l.29: 	      Circle(_) then 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.30: 	      Outside(a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.31: 	      Union(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.32: 	      Intersect(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.33: 	      Translate(_, a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.78: 	    if a is
//│ ║        	       ^^^^
//│ ║  l.79: 	      Univ then 1
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ║  l.80: 	      Empty then 1
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.81: 	      Scale(_, b) then this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.82: 	    else super.size(a)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    if a is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` does not match type `Circle | Intersect[?Region] | Outside[?Region0] | Translate[?Region1] | Union[?Region2]`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.28: 	    if r is
//│ ║        	       ^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.28: 	    if r is
//│ ║        	       ^^^^
//│ ║  l.29: 	      Circle(_) then 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.30: 	      Outside(a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.31: 	      Union(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.32: 	      Intersect(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.33: 	      Translate(_, a) then this.size(a) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from wildcard pattern:
//│ ║  l.82: 	    else super.size(a)
//│ ╙──      	         ^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.3681: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate {
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3682: 	  fun contains: (BaseRegionLang, Vector) -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3683: 	  fun eliminate: RegionLang -> RegionLang
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3684: 	  fun isEmpty: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3685: 	  fun isUniv: RegionLang -> Bool
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3686: 	  fun size: RegionLang -> Int
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3687: 	  fun text: BaseRegionLang -> Str
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.3688: 	}
//│ ║          	^
//│ ╟── expression of type `??Region & ~#Circle & ~#Empty & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ` is not an instance of type `Object`
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.78: 	    if a is
//│ ║        	       ^^^^
//│ ║  l.79: 	      Univ then 1
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ║  l.80: 	      Empty then 1
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ║  l.81: 	      Scale(_, b) then this.size(b) + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.82: 	    else super.size(a)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    if a is
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in definition of method eliminate:
//│ ║  l.2698: 	  fun eliminate(e) =
//│ ║          	      ^^^^^^^^^^^^^^
//│ ║  l.2699: 	    if e is
//│ ║          	^^^^^^^^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── wildcard pattern of type `??Region & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2706: 	    else e
//│ ║          	         ^
//│ ╟── but it flows into application with expected type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	                              ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ╙──      	                           ^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method eliminate:
//│ ║  l.2698: 	  fun eliminate(e) =
//│ ║          	      ^^^^^^^^^^^^^^
//│ ║  l.2699: 	    if e is
//│ ║          	^^^^^^^^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── wildcard pattern of type `??Region & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2706: 	    else e
//│ ║          	         ^
//│ ╟── but it flows into application with expected type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	                              ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ╙──      	                           ^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method eliminate:
//│ ║  l.2698: 	  fun eliminate(e) =
//│ ║          	      ^^^^^^^^^^^^^^
//│ ║  l.2699: 	    if e is
//│ ║          	^^^^^^^^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── wildcard pattern of type `??Region & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2706: 	    else e
//│ ║          	         ^
//│ ╟── but it flows into application with expected type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	                              ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ╙──      	                           ^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method eliminate:
//│ ║  l.2698: 	  fun eliminate(e) =
//│ ║          	      ^^^^^^^^^^^^^^
//│ ║  l.2699: 	    if e is
//│ ║          	^^^^^^^^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── wildcard pattern of type `??Region & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2706: 	    else e
//│ ║          	         ^
//│ ╟── but it flows into application with expected type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	                              ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ╙──      	                           ^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method eliminate:
//│ ║  l.2698: 	  fun eliminate(e) =
//│ ║          	      ^^^^^^^^^^^^^^
//│ ║  l.2699: 	    if e is
//│ ║          	^^^^^^^^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── wildcard pattern of type `??Region & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2706: 	    else e
//│ ║          	         ^
//│ ╟── but it flows into application with expected type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	                              ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ╙──      	                           ^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method eliminate:
//│ ║  l.2698: 	  fun eliminate(e) =
//│ ║          	      ^^^^^^^^^^^^^^
//│ ║  l.2699: 	    if e is
//│ ║          	^^^^^^^^^^^
//│ ║  l.2700: 	      Outside(Outside(a)) then this.eliminate(a)
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2702: 	      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2703: 	      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2704: 	      Translate(v, a) then Translate(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2705: 	      Scale(v, a) then Scale(v, this.eliminate(a))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.2706: 	    else e
//│ ║          	^^^^^^^^^^
//│ ╟── wildcard pattern of type `??Region & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union` does not match type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2706: 	    else e
//│ ║          	         ^
//│ ╟── but it flows into application with expected type `BaseLang[RegionLang] | ExtLang[RegionLang]`
//│ ║  l.2701: 	      Outside(a) then Outside(this.eliminate(a))
//│ ║          	                              ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.90: 	type RegionLang = BaseLang[RegionLang] | ExtLang[RegionLang]
//│ ╙──      	                           ^^^^^^^^^^
//│ module Lang {
//│   fun contains: (BaseRegionLang, Vector) -> Bool
//│   fun eliminate: RegionLang -> RegionLang
//│   fun isEmpty: RegionLang -> Bool
//│   fun isUniv: RegionLang -> Bool
//│   fun size: RegionLang -> Int
//│   fun text: BaseRegionLang -> Str
//│ }

Lang.size(circles)
//│ Int
//│ res
//│     = 13

Lang.contains(circles, Vector(0, 0))
//│ Bool
//│ res
//│     = false

Lang.text(circles)
//│ Str
//│ res
//│     = 'the union of two regions of size '

Lang.isUniv(circles)
//│ Bool
//│ res
//│     = false

Lang.isEmpty(circles)
//│ Bool
//│ res
//│     = false

Lang.size(Lang.eliminate(circles))
//│ Int
//│ res
//│     = 13

:re
Lang.size(mk(100))
//│ Int
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

:e
:re
Lang.contains(mk(100), Vector(0, 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.6621: 	Lang.contains(mk(100), Vector(0, 0))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Scale[?Region]` does not match type `Circle | Intersect[BaseRegionLang] | Outside[BaseRegionLang] | Translate[BaseRegionLang] | Union[BaseRegionLang]`
//│ ║  l.3667: 	  _ then Scale(Vector(0, 0), mk(n))
//│ ║          	         ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.23: 	type BaseLang[T] = Circle | Intersect[T] | Union[T] | Outside[T] | Translate[T]
//│ ║        	                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.489: 	type BaseRegionLang = BaseLang[BaseRegionLang]
//│ ╙──       	                               ^^^^^^^^^^^^^^
//│ error | false | true
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

:e
:re
Lang.text(mk(100))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.6641: 	Lang.text(mk(100))
//│ ║          	^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Scale[?Region]` does not match type `Circle | Intersect[BaseRegionLang] | Outside[BaseRegionLang] | Translate[BaseRegionLang] | Union[BaseRegionLang]`
//│ ║  l.3667: 	  _ then Scale(Vector(0, 0), mk(n))
//│ ║          	         ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.23: 	type BaseLang[T] = Circle | Intersect[T] | Union[T] | Outside[T] | Translate[T]
//│ ║        	                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.489: 	type BaseRegionLang = BaseLang[BaseRegionLang]
//│ ╙──       	                               ^^^^^^^^^^^^^^
//│ Str | error
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

:re
Lang.isUniv(mk(100))
//│ Bool
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

:re
Lang.isEmpty(mk(100))
//│ Bool
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

:re
Lang.size(Lang.eliminate(mk(100)))
//│ Int
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded
