:NewDefs
:GADTs


abstract class Foo0[type T] {
  fun x: T
}
abstract class Bar0 extends Foo0[Int]
//│ abstract class Foo0[T] {
//│   fun x: T
//│ }
//│ abstract class Bar0 extends Foo0 {
//│   fun x: 'T
//│ }
//│ where
//│   'T := Int

abstract class Foo[type T]: Bar | Baz {
  fun x: T
  fun f: T -> Int
}
abstract class Bar extends Foo[Int]
abstract class Baz extends Foo[Str]
//│ abstract class Foo[T]: Bar | Baz {
//│   fun f: T -> Int
//│   fun x: T
//│ }
//│ abstract class Bar extends Foo {
//│   fun f: 'T -> Int
//│   fun x: 'T
//│ }
//│ abstract class Baz extends Foo {
//│   fun f: 'T0 -> Int
//│   fun x: 'T0
//│ }
//│ where
//│   'T0 := Str
//│   'T := Int

:e // Expected
fun test(f: Foo) = f.f(f.x)
//│ ╔══[ERROR] Type error in application
//│ ║  l.41: 	fun test(f: Foo) = f.f(f.x)
//│ ║        	                   ^^^^^^^^
//│ ╟── type variable `T` leaks out of its scope
//│ ║  l.19: 	  fun x: T
//│ ║        	      ^^^^
//│ ╟── back into type variable `T`
//│ ║  l.18: 	abstract class Foo[type T]: Bar | Baz {
//│ ╙──      	                        ^
//│ fun test: (f: Foo[in anything out nothing]) -> (Int | error)

fun test(f: Foo) = if f is
  Foo then f.f(f.x)
//│ fun test: (f: Foo[in anything out nothing]) -> Int

fun test(f: Foo) = if f is
  Foo then f.x : f.T
//│ fun test: (f: Foo[in anything out nothing]) -> (??T & ??T0)

fun test(f: Foo['a]) = if f is
  Foo then f.x : f.T
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.62: 	  Foo then f.x : f.T
//│ ║        	           ^^^
//│ ╟── type `Str` does not match type `'a | ?T | ?T0 | T`
//│ ║  l.23: 	abstract class Baz extends Foo[Str]
//│ ║        	                               ^^^
//│ ╟── but it flows into field selection with expected type `'a | ?T1 | ?T2 | T`
//│ ║  l.62: 	  Foo then f.x : f.T
//│ ║        	           ^^^
//│ ╟── Note: constraint arises from type selection:
//│ ║  l.62: 	  Foo then f.x : f.T
//│ ╙──      	                  ^^
//│ fun test: forall 'a. (f: Foo['a]) -> ('a & ??T & (Int | Str))



fun test(f: Foo0['a]) = if f is
  Foo0 then f.x : f.T // here, locally we have f.T =:= `T & 'a where `T is the local skolem for x.T
//│ fun test: forall 'a. (f: Foo0['a]) -> (??T & 'a)

// * NOTE: refined f.T =:= `T & 'a
fun test(f: Foo0['a]) = if f is
  Foo0 then f.x : f.T
  _ then error
//│ fun test: forall 'a. (f: Foo0['a]) -> (??T & 'a)

// * TODO: why don't we get 'a in the result whereas we do in the Foo0 case above?
fun test(f: Foo0['a]) = if f is
  Bar0 then 123 : f.T
  _ then error
//│ fun test: forall 'a. (f: Foo0['a]) -> (Int & 'a)

// ^ What's haoppening:
// Bar & {} <: { T: 'l..'u }
// ^ What SHOULD be haoppening:
// Bar & Foo0['a] <: { T: 'l..'u }
// Notice that field T in `Bar & Foo0['a]` should yield `'a | Int .. 'a & Int`
// Alternative (not great; not clear how to do it generally/in a principled way):
// Bar & {T: 'a .. 'a } <: { T: 'l..'u }


fun test(x: 'a, g: Foo0[x], f: Foo0[x]) = if f is
  Bar0 then 123 : g.T
  _ then error
//│ fun test: forall 'a. (x: 'a, g: Foo0['a], f: Foo0['a]) -> 'a
//│   where
//│     'a :> 123


fun test(f: Foo) = if f is
  Foo then f.f(f.x : f.T)
//│ fun test: (f: Foo[in anything out nothing]) -> Int

fun test(f: Foo) = if f is
    Bar then f.x
  else error
//│ fun test: (f: Foo[in anything out nothing]) -> Int

fun test(f: Foo) = if f is
    Bar then f.x : f.T
  else error
//│ fun test: (f: Foo[in anything out nothing]) -> Int

// FIXME
fun test(f: Foo) = if f is
    Bar then 123 : f.T
    Baz then error
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.127: 	fun test(f: Foo) = if f is
//│ ║         	                      ^^^^
//│ ║  l.128: 	    Bar then 123 : f.T
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.129: 	    Baz then error
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── type `Foo[?]` does not match type `Bar | Baz`
//│ ║  l.127: 	fun test(f: Foo) = if f is
//│ ║         	            ^^^
//│ ╟── but it flows into reference with expected type `Bar | Baz`
//│ ║  l.127: 	fun test(f: Foo) = if f is
//│ ╙──       	                      ^
//│ fun test: (f: Foo[in anything out nothing]) -> Int

fun test(f: Foo) = if f is
    Bar then 123 : f.T
    Baz then "hello" : f.T
    _ then error
//│ fun test: (f: Foo[in anything out nothing]) -> (Int | Str)

fun test(f: Foo['a]) = if f is
    Bar then 123 : f.T
    Baz then "hello" : f.T
    _ then error
//│ fun test: forall 'a. (f: Foo['a]) -> ('a & (Int | Str))

fun test(f: Foo, x) = x : f.T
//│ fun test: (f: Foo[in anything out nothing], ??T) -> ??T0

fun test[A](f: Foo[A]): A = if f is
    Bar then 123 : f.T
    Baz then "hello" : f.T
//│ fun test: forall 'A. (f: Foo['A]) -> 'A

fun test(f: Foo['a]): f.T = if f is
    Bar then 123 : f.T
    Baz then "hello" : f.T
//│ fun test: forall 'a. (f: Foo['a]) -> ('a & (Int | Str))

:e // expected
test(error, 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.171: 	test(error, 1)
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── argument list of type `[nothing, 1]` does not match type `[f: Foo['a]]`
//│ ║  l.171: 	test(error, 1)
//│ ║         	    ^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.165: 	fun test(f: Foo['a]): f.T = if f is
//│ ╙──       	        ^^^^^^^^^^^^
//│ error
//│ res
//│ Runtime error:
//│   Error: an error was thrown

