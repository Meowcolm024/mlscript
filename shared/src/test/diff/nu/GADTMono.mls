:NewDefs
:NoJS

trait Expr[A]: LitInt | LitBool | Add | Cond | Pair | Fst | Snd
class LitInt(n: int) extends Expr[int]
class LitBool(b: bool) extends Expr[bool]
class Add(x: Expr[int], y: Expr[int]) extends Expr[int]
class Cond[T](p: Expr[bool], t: Expr[T], e: Expr[T]) extends Expr[T]
class Pair[S, T](a: Expr[S], b: Expr[T]) extends Expr[(S, T)]
class Fst[S, T](p: Expr[(S, T)]) extends Expr[S]
class Snd[S, T](p: Expr[(S, T)]) extends Expr[T]
//│ trait Expr[A]()
//│ class LitInt(n: int)
//│ class LitBool(b: bool)
//│ class Add(x: Expr[int], y: Expr[int])
//│ class Cond[T](p: Expr[bool], t: Expr[T], e: Expr[T])
//│ class Pair[S, T](a: Expr[S], b: Expr[T])
//│ class Fst[S, T](p: Expr[(S, T,)])
//│ class Snd[S, T](p: Expr[(S, T,)])

let l1 = LitInt(1)
//│ let l1: LitInt

l1: Expr[int]
//│ Expr[int]

:e
l1: Expr[bool]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.28: 	l1: Expr[bool]
//│ ║        	^^
//│ ╟── type `int` is not an instance of `bool`
//│ ║  l.5: 	class LitInt(n: int) extends Expr[int]
//│ ║       	                                  ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.28: 	l1: Expr[bool]
//│ ╙──      	         ^^^^
//│ Expr[bool]


fun eval(e) =
  if e is LitInt(n) then n
  else 0
//│ fun eval: anything -> int

:e
fun eval[A](e: Expr[A]): A =
  if e is LitInt(n) then n
  else 0
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.48: 	  if e is LitInt(n) then n
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.49: 	  else 0
//│ ║        	^^^^^^^^
//│ ╟── type `int` does not match type `A`
//│ ║  l.5: 	class LitInt(n: int) extends Expr[int]
//│ ║       	                ^^^
//│ ╟── but it flows into reference with expected type `A`
//│ ║  l.48: 	  if e is LitInt(n) then n
//│ ╙──      	     ^
//│ fun eval: forall 'A. (e: Expr['A],) -> 'A


// FIXME
fun eval[A](e: Expr[A]): A =
  if 
    e is LitInt(n) then n
    e is LitBool(b) then b
    e is Add(x, y) then eval(x) + eval(y)
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.67: 	    e is LitInt(n) then n
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.68: 	    e is LitBool(b) then b
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.69: 	    e is Add(x, y) then eval(x) + eval(y)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `#Expr & (Add & {Expr#A = A} | Cond[?] & {Expr#A = A} | Fst[?, ?] & {Expr#A = A} | LitBool & {Expr#A = A} | LitInt & {Expr#A = A} | Pair[?, ?] & {Expr#A = A} | Snd[?, ?] & {Expr#A = A})` does not match type `Add | LitBool | LitInt`
//│ ║  l.65: 	fun eval[A](e: Expr[A]): A =
//│ ║        	               ^^^^^^^
//│ ╟── but it flows into reference with expected type `Add | LitBool | LitInt`
//│ ║  l.67: 	    e is LitInt(n) then n
//│ ╙──      	    ^
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.67: 	    e is LitInt(n) then n
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.68: 	    e is LitBool(b) then b
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.69: 	    e is Add(x, y) then eval(x) + eval(y)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` does not match type `A`
//│ ║  l.5: 	class LitInt(n: int) extends Expr[int]
//│ ║       	                ^^^
//│ ╟── but it flows into reference with expected type `A`
//│ ║  l.67: 	    e is LitInt(n) then n
//│ ╙──      	    ^
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.65: 	fun eval[A](e: Expr[A]): A =
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.66: 	  if 
//│ ║        	^^^^^
//│ ║  l.67: 	    e is LitInt(n) then n
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.68: 	    e is LitBool(b) then b
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.69: 	    e is Add(x, y) then eval(x) + eval(y)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` does not match type `A`
//│ ║  l.7: 	class Add(x: Expr[int], y: Expr[int]) extends Expr[int]
//│ ╙──     	                                ^^^
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.65: 	fun eval[A](e: Expr[A]): A =
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.66: 	  if 
//│ ║        	^^^^^
//│ ║  l.67: 	    e is LitInt(n) then n
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.68: 	    e is LitBool(b) then b
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.69: 	    e is Add(x, y) then eval(x) + eval(y)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `A` is not an instance of type `int`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.7: 	class Add(x: Expr[int], y: Expr[int]) extends Expr[int]
//│ ╙──     	                                ^^^
//│ fun eval: forall 'A. (e: Expr['A],) -> 'A

