:NewDefs


class C[A](x: A) {
  fun foo = x
}
//│ class C[A](x: A) {
//│   fun foo: A
//│ }

let c = C(123)
//│ let c: C[123]
//│ c
//│   = C {}

class B
//│ class B {
//│   constructor()
//│ }

fun bar(c) = if c is
  C(y) then y
  B    then 0
//│ fun bar: forall 'A. (B | C['A]) -> (0 | ??A & 'A)

bar(c)
//│ 0 | 123 & ??A
//│ res
//│     = 123

fun bar(c) = if c is
    C(y) then y + 1
    B    then 0
  else 1
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.31: 	fun bar(c) = if c is
//│ ║        	                ^^^^
//│ ║  l.32: 	    C(y) then y + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `A & ?A` is not an instance of type `Int`
//│ ║  l.4: 	class C[A](x: A) {
//│ ║       	           ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.32: 	    C(y) then y + 1
//│ ╙──      	              ^
//│ fun bar: (C[anything] | Object & ~#C) -> (Int | error)

bar(c)
//│ Int | error
//│ res
//│     = 124

:e
bar(C(true))
//│ Int | error
//│ res
//│     = 2

