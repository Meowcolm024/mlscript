:NewDefs
:GADTs

fun fst([x, y]) = x
fun snd([x, y]) = y 
fun (++) stringConcat(a, b) = concat(a)(b)
//│ fun fst: forall 'a. (['a, anything]) -> 'a
//│ fun snd: forall 'b. ([anything, 'b]) -> 'b
//│ fun (++) stringConcat: (Str, Str) -> Str

// statically typed format //

abstract class Format[type F]: D[F] | B[F] | L[F] | E
class D[F](fmt: Format[F]) extends Format[Int -> F]
class B[F](fmt: Format[F]) extends Format[Bool -> F]
class L[F](s: Str, fmt: Format[F]) extends Format[F]
module E extends Format[Str]
//│ abstract class Format[F]: B[F] | D[F] | E | L[F]
//│ class D[F](fmt: Format[F]) extends Format
//│ class B[F](fmt: Format[F]) extends Format
//│ class L[F](s: Str, fmt: Format[F]) extends Format
//│ module E extends Format

fun fmtGo: (Str, Format['F]) -> 'F
fun fmtGo(acc, f) = if f is
    D(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
    B(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
    L(s, fmt) then fmtGo(acc ++ s, fmt) : f.F
    E         then acc : f.F
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.25: 	fun fmtGo(acc, f) = if f is
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.26: 	    D(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.27: 	    B(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.28: 	    L(s, fmt) then fmtGo(acc ++ s, fmt) : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.29: 	    E         then acc : f.F
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Int -> (??F & ?F)` does not match type `'F`
//│ ║  l.14: 	class D[F](fmt: Format[F]) extends Format[Int -> F]
//│ ║        	                                          ^^^^^^^^
//│ ╟── but it flows into type selection with expected type `'F`
//│ ║  l.26: 	    D(fmt)    then (i => fmtGo(acc ++ toString(i),fmt)) : f.F
//│ ║        	                                                           ^^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.24: 	fun fmtGo: (Str, Format['F]) -> 'F
//│ ╙──      	                                ^^
//│ fun fmtGo: forall 'F 'F0 'F1. (Str, B[in 'F out nothing] | D[in 'F0 out nothing] | E | L[in 'F1 out nothing]) -> (Str | nothing -> (??F & 'F | ??F0 & 'F0) | ??F1 & 'F1)
//│ fun fmtGo: forall 'F2. (Str, Format['F2]) -> 'F2

fun fmt(f) = fmtGo("", f)
//│ fun fmt: forall 'F. Format['F] -> 'F

let test = L("int i = ", D(L(", bool b = ", B(E))))
//│ let test: L[Int -> 'F]
//│   where
//│     'F := Bool -> Str
//│ test
//│      = L {}

fmt(test)
//│ Int -> Bool -> Str
//│ res
//│     = [Function (anonymous)]

fmt(test)(114)(false)
//│ Str
//│ res
//│     = 'int i = 114, bool b = false'

:e
fmt(test)("hello")("world")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.74: 	fmt(test)("hello")("world")
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"hello"` is not an instance of type `Int`
//│ ║  l.74: 	fmt(test)("hello")("world")
//│ ║        	          ^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.14: 	class D[F](fmt: Format[F]) extends Format[Int -> F]
//│ ╙──      	                                          ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.74: 	fmt(test)("hello")("world")
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"world"` is not an instance of type `Bool`
//│ ║  l.74: 	fmt(test)("hello")("world")
//│ ║        	                   ^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.15: 	class B[F](fmt: Format[F]) extends Format[Bool -> F]
//│ ╙──      	                                          ^^^^
//│ Str | error
//│ res
//│     = 'int i = hello, bool b = world'


// typed ast //

abstract class Expr[type T]: Lit | Plus| Equals | If | Pair | Fst
class Lit(i: Int) extends Expr[Int]
class Plus(a: Expr[Int], b: Expr[Int]) extends Expr[Int]
class Equals(a: Expr[Int], b: Expr[Int]) extends Expr[Bool]
class If[A](p: Expr[Bool],a: Expr[A],b: Expr[A]) extends Expr[A]
class Pair[A, B](a: Expr[A], b: Expr[B]) extends Expr[[A, B]]
class Fst[A, B](p: Expr[[A, B]]) extends Expr[A]
//│ abstract class Expr[T]: Equals | Fst[?, ?] | If[?] | Lit | Pair[?, ?] | Plus
//│ class Lit(i: Int) extends Expr
//│ class Plus(a: Expr[Int], b: Expr[Int]) extends Expr
//│ class Equals(a: Expr[Int], b: Expr[Int]) extends Expr
//│ class If[A](p: Expr[Bool], a: Expr[A], b: Expr[A]) extends Expr
//│ class Pair[A, B](a: Expr[A], b: Expr[B]) extends Expr
//│ class Fst[A, B](p: Expr[[A, B]]) extends Expr

fun eval: Expr['T] -> 'T
fun eval(e: Expr['t]): e.T = if e is
    Lit(i) then i : e.T
    Plus(a, b) then eval(a) + eval(b) : e.T
    Equals(a, b) then (eval(a) == eval(b)) : e.T
    If(p, a, b) then if eval(p) then eval(a) : e.T else eval(b) : e.T
    Pair(a, b) then [eval(a), eval(b)] : e.T
    Fst(p) then fst(eval(p)) : e.T
//│ fun eval: forall 't. (e: Expr['t]) -> ('t & (Int | false | true | [??A, ??B] | ??A0 | ??A1))
//│ fun eval: forall 'T. Expr['T] -> 'T

eval(Plus(Lit(1), Lit(1)))
//│ Int
//│ res
//│     = 2

eval(If(Equals(Lit(3), Plus(Lit(1), Lit(1))), Fst(Pair(Lit(1), Lit(2))), Lit(3)))
//│ Int
//│ res
//│     = 3

:e
eval(Plus(Equals(Lit(1), Lit(2)), Lit(3)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.137: 	eval(Plus(Equals(Lit(1), Lit(2)), Lit(3)))
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Bool` is not an instance of `Int`
//│ ║  l.103: 	class Equals(a: Expr[Int], b: Expr[Int]) extends Expr[Bool]
//│ ║         	                                                      ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.102: 	class Plus(a: Expr[Int], b: Expr[Int]) extends Expr[Int]
//│ ╙──       	                   ^^^
//│ Int
//│ res
//│     = 3
