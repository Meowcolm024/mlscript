:NewDefs
:GADTs

abstract class Foo[type T]: Bar | Baz
class Bar extends Foo[Int]
class Baz[T](val x: Foo[T]) extends Foo[[T]]
//│ abstract class Foo[T]: Bar | Baz[?]
//│ class Bar extends Foo {
//│   constructor()
//│ }
//│ class Baz[T](x: Foo[T]) extends Foo

// TODO
fun foo[T](f: Foo[T]): Int = if f is
    Bar then 0
    Baz(x) then foo(x : Foo[x.T])
//│ ╔══[ERROR] Subtyping constraint of the form `([?a]) -> ?b <: ?c -> ?d` exceeded recursion depth limit (250)
//│ ║  l.14: 	fun foo[T](f: Foo[T]): Int = if f is
//│ ║        	                                ^^^^
//│ ║  l.15: 	    Bar then 0
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.16: 	    Baz(x) then foo(x : Foo[x.T])
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ ╔══[ERROR] Type error in definition
//│ ║  l.14: 	fun foo[T](f: Foo[T]): Int = if f is
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.15: 	    Bar then 0
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.16: 	    Baz(x) then foo(x : Foo[x.T])
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `T` leaks out of its scope
//│ ║  l.16: 	    Baz(x) then foo(x : Foo[x.T])
//│ ║        	                             ^^
//│ ╙── into expression of type `T | ~(Int & ??T)`
//│ ╔══[ERROR] Type error in definition
//│ ║  l.14: 	fun foo[T](f: Foo[T]): Int = if f is
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.15: 	    Bar then 0
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.16: 	    Baz(x) then foo(x : Foo[x.T])
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `T` leaks out of its scope
//│ ║  l.6: 	class Baz[T](val x: Foo[T]) extends Foo[[T]]
//│ ╙──     	          ^
//│ fun foo: forall 'T. (f: Foo['T]) -> Int

fun foo: Foo['a] -> Int
fun foo(f) = if f is
    Bar then 0
    Baz(x) then foo(x)
//│ fun foo: (Bar | Baz[in anything out nothing]) -> Int
//│ fun foo: forall 'a. Foo['a] -> Int

abstract class Foo[type T]: Bar | Baz[T]
class Bar extends Foo[Int]
class Baz[T](val x: Foo[T]) extends Foo[[T]]
//│ abstract class Foo[T]: Bar | Baz[T]
//│ class Bar extends Foo {
//│   constructor()
//│ }
//│ class Baz[T](x: Foo[T]) extends Foo

fun foo[T](f: Foo[T]): Int = if f is
    Bar then 0
    Baz(x) then foo(x : Foo[x.T])
//│ fun foo: forall 'T. (f: Foo['T]) -> Int

fun bar(f) = if f is 
    Bar then 0
    Baz(_) then 1
//│ fun bar: (Bar | Baz[in anything out nothing]) -> (0 | 1)

bar(Baz(new Bar))
//│ 0 | 1
//│ res
//│     = 1

abstract class C[type T]: D1 | D2
class D1 extends C[Int]
class D2[A, B](val a: C[A], val b: C[B]) extends C[[A, B]]
//│ abstract class C[T]: D1 | D2[?, ?]
//│ class D1 extends C {
//│   constructor()
//│ }
//│ class D2[A, B](a: C[A], b: C[B]) extends C


abstract class C[type T]: C1 | C2
class C1[type A](c: A) extends C[A]
class C2 extends C[Int]
//│ abstract class C[T]: C1[anything] | C2
//│ class C1[A](c: A) extends C
//│ class C2 extends C {
//│   constructor()
//│ }

fun foo: C['T] -> 'T
fun foo(x) = if x is
    C1(c) then c : x.T
    C2    then 0 : x.T
//│ ╔══[ERROR] Type error in definition
//│ ║  l.99: 	fun foo(x) = if x is
//│ ║        	    ^^^^^^^^^^^^^^^^
//│ ║  l.100: 	    C1(c) then c : x.T
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.101: 	    C2    then 0 : x.T
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.100: 	    C1(c) then c : x.T
//│ ║         	                    ^^
//│ ╟── into type `'T | ~??A`
//│ ║  l.98: 	fun foo: C['T] -> 'T
//│ ╙──      	                  ^^
//│ fun foo: forall 'A. (C1['A] | C2) -> (Int | ??A & 'A)
//│ fun foo: forall 'T. C['T] -> 'T

foo(C1(true))
//│ true
//│ res
//│     = true

foo(new C2)
//│ Int
//│ res
//│     = 0

abstract class Option[type T]: None | Some[T]
module None extends Option[nothing]
class Some[A](get: A) extends Option[A]
//│ abstract class Option[T]: None | Some[T]
//│ module None extends Option
//│ class Some[A](get: A) extends Option

:d
fun getOr(x, d) = if x is
    None then d
    Some(g) then g
//│ 0. Typing ‹fun getOr = (x, d,) => if x is ‹(None) then d; (Some(g,)) then g››
//│ | 0. Created lazy type info for fun getOr = (x, d,) => if x is ‹(None) then d; (Some(g,)) then g›
//│ | Completing fun getOr = (x, d,) => if x is ‹(None) then d; (Some(g,)) then g›
//│ | | Type params 
//│ | | Params 
//│ | | 1. Typing term (x, d,) => if x is ‹(None) then d; (Some(g,)) then g›
//│ | | | 1. Typing pattern [x, d,]
//│ | | | | 1. Typing pattern x
//│ | | | | 1. : x591'
//│ | | | | 1. Typing pattern d
//│ | | | | 1. : d592'
//│ | | | 1. : (x591', d592',)
//│ | | | 1. Typing term if x is ‹(None) then d; (Some(g,)) then g›
//│ | | | | [Desugarer.destructPattern] scrutinee = x; pattern = None
//│ | | | | [Desugarer.destructPattern] Result: «x is None»
//│ | | | | [Desugarer.destructPattern] scrutinee = x; pattern = Some(g,)
//│ | | | | [Desugarer.destructPattern] Result: «x is Some»
//│ | | | | Desugared term: case x of { None => d; Some => (([g,],) => g)((Some).unapply(x,),) }
//│ | | | | 1. Typing term case x of { None => d; Some => (([g,],) => g)((Some).unapply(x,),) }
//│ | | | | | 1. Typing term x
//│ | | | | | 1. : x591'
//│ | | | | | CONSTRAIN x591' <! Object
//│ | | | | |   where 
//│ | | | | | 1. C x591' <! Object    (0)
//│ | | | | | | NEW x591' UB (0)
//│ | | | | | >>>c Map(T -> NuParam(TypeName(T),mut T571_575#..T571_575#,true))
//│ | | | | | Match arm None: #None<Object,Option> & ⊤ intl ⊤
//│ | | | | | var rfn: x :: x591' & #None<Object,Option> & ⊤
//│ | | | | | 2. Typing term d
//│ | | | | | 2. : d592'
//│ | | | | | CONSTRAIN d592' <! α593'
//│ | | | | |   where 
//│ | | | | | 2. C d592' <! α593'    (0)
//│ | | | | | | NEW d592' UB (1)
//│ | | | | | >>>c Map(T -> NuParam(TypeName(T),mut T571_578'#..T571_578'#,true), Some#A -> NuParam(TypeName(A),mut A576'..A576',true), get -> NuParam(get,‘A576',false))
//│ | | | | | Match arm Some: #Some<Object,Option> & {Some#A: mut A576_594'..A576_595'} intl {Some#A: mut (A576_594' | ‘A596'')..(A576_595' & ‘A596'')}
//│ | | | | | var rfn: x :: x591' & #Some<Object,Option> & {Some#A: mut (A576_594' | ‘A596'')..(A576_595' & ‘A596'')}
//│ | | | | | 2. Typing term (([g,],) => g)((Some).unapply(x,),)
//│ | | | | | | 2. Typing term ([g,],) => g
//│ | | | | | | | 2. Typing pattern [[g,],]
//│ | | | | | | | | 2. Typing pattern [g,]
//│ | | | | | | | | | 2. Typing pattern g
//│ | | | | | | | | | 2. : g598''
//│ | | | | | | | | 2. : (g598'',)
//│ | | | | | | | 2. : ((g598'',),)
//│ | | | | | | | 2. Typing term g
//│ | | | | | | | 2. : g598''
//│ | | | | | | 2. : ([g598'',] -> g598'')
//│ | | | | | | 2. Typing term (Some).unapply(x,)
//│ | | | | | | | 2. Typing term (Some).unapply
//│ | | | | | | | | 2. Typing term (x,) => let _ = x : Some in [(x).#get,]
//│ | | | | | | | | | TYPING POLY LAM
//│ | | | | | | | | | 3. Typing pattern [x,]
//│ | | | | | | | | | | 3. Typing pattern x
//│ | | | | | | | | | | 3. : x599'''
//│ | | | | | | | | | 3. : (x599''',)
//│ | | | | | | | | | 3. Typing term let _ = x : Some in [(x).#get,]
//│ | | | | | | | | | | 3. Typing term x : Some
//│ | | | | | | | | | | | 3. Typing term x
//│ | | | | | | | | | | | 3. : x599'''
//│ | | | | | | | | | | | Typing type TypeName(Some)
//│ | | | | | | | | | | | | vars=Map() newDefsInfo=Map()
//│ | | | | | | | | | | | | 3. type TypeName(Some)
//│ | | | | | | | | | | | | => #Some<Object,Option>
//│ | | | | | | | | | | | => #Some<Object,Option> ——— 
//│ | | | | | | | | | | | CONSTRAIN x599''' <! #Some<Object,Option>
//│ | | | | | | | | | | |   where 
//│ | | | | | | | | | | | 3. C x599''' <! #Some<Object,Option>    (0)
//│ | | | | | | | | | | | | NEW x599''' UB (0)
//│ | | | | | | | | | | 3. : #Some<Object,Option>
//│ | | | | | | | | | | 3. Typing term [(x).#get,]
//│ | | | | | | | | | | | 3. Typing term (x).#get
//│ | | | | | | | | | | | | 3. Typing term x
//│ | | | | | | | | | | | | 3. : x599'''
//│ | | | | | | | | | | | | CONSTRAIN x599''' <! {#get: #get600'''}
//│ | | | | | | | | | | | |   where 
//│ 		x599''' <: #Some<Object,Option>
//│ | | | | | | | | | | | | 3. C x599''' <! {#get: #get600'''}    (0)
//│ | | | | | | | | | | | | | NEW x599''' UB (3)
//│ | | | | | | | | | | | 3. : #get600'''
//│ | | | | | | | | | | 3. : (#get600''',)
//│ | | | | | | | | | 3. : (#get600''',)
//│ | | | | | | | | | Inferred poly constr: (x599''' -> (#get600''',))  —— where 
//│ 		x599''' <: {#get: #get600'''} & #Some<Object,Option>
//│ | | | | | | | | 2. : ‹∀ 2. (x599''' -> (#get600''',))›
//│ | | | | | | | 2. : ‹∀ 2. (x599''' -> (#get600''',))›
//│ | | | | | | | 2. Typing term x
//│ | | | | | | | 2. : ((x591' & #Some<Object,Option>) & {Some#A: mut (A576_594' | ‘A596'')..(A576_595' & ‘A596'')})
//│ | | | | | | | CONSTRAIN ‹∀ 2. (x599''' -> (#get600''',))› <! (((x591' & #Some<Object,Option>) & {Some#A: mut (A576_594' | ‘A596'')..(A576_595' & ‘A596'')}) -> α601'')
//│ | | | | | | |   where 
//│ 		x591' <: Object
//│ 		A576_594' <: A576_595'
//│ 		x599''' <: {#get: #get600'''} & #Some<Object,Option>
//│ | | | | | | | 2. C ‹∀ 2. (x599''' -> (#get600''',))› <! (((x591' & #Some<Object,Option>) & {Some#A: mut (A576_594' | ‘A596'')..(A576_595' & ‘A596'')}) -> α601'')    (0)
//│ | | | | | | | | could be distribbed: Set(#get600''')
//│ | | | | | | | | cannot be distribbed: Set(x599''', #get600''')
//│ | | | | | | | | INST [2]   ‹∀ 2. (x599''' -> (#get600''',))›
//│ | | | | | | | |   where  
//│ 		x599''' <: {#get: #get600'''} & #Some<Object,Option>
//│ | | | | | | | | TO [2] ~>  (x599_602'' -> (#get600_603'',))
//│ | | | | | | | |   where  
//│ 		x599_602'' <: {#get: #get600_603''} & #Some<Object,Option>
//│ | | | | | | | | 2. C (x599_602'' -> (#get600_603'',)) <! (((x591' & #Some<Object,Option>) & {Some#A: mut (A576_594' | ‘A596'')..(A576_595' & ‘A596'')}) -> α601'')    (2)
//│ | | | | | | | | | 2. C (((x591' & #Some<Object,Option>) & {Some#A: mut (A576_594' | ‘A596'')..(A576_595' & ‘A596'')}),) <! (x599_602'',)    (2)
//│ | | | | | | | | | | 2. C ((x591' & #Some<Object,Option>) & {Some#A: mut (A576_594' | ‘A596'')..(A576_595' & ‘A596'')}) <! x599_602''    (3)
//│ | | | | | | | | | | | NEW x599_602'' LB (2)
//│ | | | | | | | | | | | 2. C ((x591' & #Some<Object,Option>) & {Some#A: mut (A576_594' | ‘A596'')..(A576_595' & ‘A596'')}) <! {#get: #get600_603''}    (6)
//│ | | | | | | | | | | | | 2. ARGH  DNF(2, #Some<Object,Option>{Some#A: mut (A576_594' | ‘A596'')..(‘A596'' & A576_595')}∧x591')  <!  DNF(2, {#get: #get600_603''})
//│ | | | | | | | | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | | | | | | | | Consider #Some<Object,Option>{Some#A: mut (A576_594' | ‘A596'')..(‘A596'' & A576_595')} <: DNF(2, {#get: #get600_603''})
//│ | | | | | | | | | | | | | Possible: List({#get: #get600_603''})
//│ | | | | | | | | | | | | | 2. A  #Some<Object,Option>{Some#A: mut (A576_594' | ‘A596'')..(‘A596'' & A576_595')}  %  List()  <!  List({#get: #get600_603''})  %  ⊥
//│ | | | | | | | | | | | | | | 2. A  #Some<Object,Option>{Some#A: mut (A576_594' | ‘A596'')..(‘A596'' & A576_595')}  %  List()  <!  List()  %  {#get:#get600_603''}
//│ | | | | | | | | | | | | | | | 2. A  #Some<Object,Option>{Some#A: mut (A576_594' | ‘A596'')..(‘A596'' & A576_595')}  %  List()  <!  List()  %  |{#get:#get600_603''}
//│ | | | | | | | | | | | | | | | | Looking up field #get in Some(Some) & TreeSet() & {...}
//│ | | | | | | | | | | | | | | | | | Lookup Some.get : Some(‘A576') where 
//│ | | | | | | | | | | | | | | | | | Lookup: Found mut (A576_594' | ‘A596'')..(‘A596'' & A576_595')
//│ | | | | | | | | | | | | | | | | | Fresh[0] Some.get : Some((A576_594' | ‘A596'')..(‘A596'' & A576_595')) where Some(
//│ 		A576_594' <: A576_595')
//│ | | | | | | | | | | | | | | | | |   & None  (from refinement)
//│ | | | | | | | | | | | | | | | | 2. C (A576_594' | ‘A596'')..(‘A596'' & A576_595') <! #get600_603''    (5)
//│ | | | | | | | | | | | | | | | | | 2. C (‘A596'' & A576_595') <! #get600_603''    (8)
//│ | | | | | | | | | | | | | | | | | | NEW #get600_603'' LB (2)
//│ | | | | | | | | | | | 2. C ((x591' & #Some<Object,Option>) & {Some#A: mut (A576_594' | ‘A596'')..(A576_595' & ‘A596'')}) <! #Some<Object,Option>    (6)
//│ | | | | | | | | | | | | Already a subtype by <:<
//│ | | | | | | | | | 2. C (#get600_603'',) <! α601''    (2)
//│ | | | | | | | | | | NEW α601'' LB (2)
//│ | | | | | | 2. : α601''
//│ | | | | | | CONSTRAIN ([g598'',] -> g598'') <! (α601'' -> α604'')
//│ | | | | | |   where 
//│ 		α601'' :> (#get600_603'',)
//│ 		#get600_603'' :> (‘A596'' & A576_595')
//│ | | | | | | 2. C ([g598'',] -> g598'') <! (α601'' -> α604'')    (0)
//│ | | | | | | | 2. C (α601'',) <! ((g598'',),)    (1)
//│ | | | | | | | | 2. C α601'' <! (g598'',)    (2)
//│ | | | | | | | | | NEW α601'' UB (2)
//│ | | | | | | | | | 2. C (#get600_603'',) <! (g598'',)    (4)
//│ | | | | | | | | | | 2. C #get600_603'' <! g598''    (4)
//│ | | | | | | | | | | | NEW #get600_603'' UB (2)
//│ | | | | | | | | | | | 2. C (‘A596'' & A576_595') <! g598''    (6)
//│ | | | | | | | | | | | | NEW g598'' LB (2)
//│ | | | | | | | 2. C g598'' <! α604''    (1)
//│ | | | | | | | | NEW g598'' UB (2)
//│ | | | | | | | | 2. C (‘A596'' & A576_595') <! α604''    (3)
//│ | | | | | | | | | NEW α604'' LB (2)
//│ | | | | | 2. : α604''
//│ | | | | | CONSTRAIN α604'' <! α597'
//│ | | | | |   where 
//│ 		α604'' :> (‘A596'' & A576_595')
//│ | | | | | 2. C α604'' <! α597'    (0)
//│ | | | | | | NEW α604'' UB (1)
//│ | | | | | | 2. C (‘A596'' & A576_595') <! α597'    (2)
//│ | | | | | | | wrong level: 2
//│ | | | | | | | EXTR LHS  ~>  (⊤(‘A596'') & A576_595')  to 1
//│ | | | | | | |  where 
//│ | | | | | | | 2. C (⊤(‘A596'') & A576_595') <! α597'    (4)
//│ | | | | | | | | NEW α597' LB (1)
//│ | | | | | CONSTRAIN x591' <! (#None<Object,Option> | ((#Some<Object,Option> & {Some#A: mut A576_594'..A576_595'}) & ~(#None<Object,Option>)))
//│ | | | | |   where 
//│ 		x591' <: Object
//│ 		A576_594' <: A576_595'
//│ | | | | | 1. C x591' <! (#None<Object,Option> | ((#Some<Object,Option> & {Some#A: mut A576_594'..A576_595'}) & ~(#None<Object,Option>)))    (0)
//│ | | | | | | NEW x591' UB (1)
//│ | | | | 1. : (α593' | α597')
//│ | | | 1. : (α593' | α597')
//│ | | 1. : ((x591', d592',) -> (α593' | α597'))
//│ | | CONSTRAIN ((x591', d592',) -> (α593' | α597')) <! getOr605'
//│ | |   where 
//│ 		x591' <: (#None<Object,Option> | ((#Some<Object,Option> & {Some#A: mut A576_594'..A576_595'}) & ~(#None<Object,Option>))) & Object
//│ 		d592' <: α593'
//│ 		A576_594' <: A576_595'
//│ 		α597' :> (⊤(‘A596'') & A576_595')
//│ | | 1. C ((x591', d592',) -> (α593' | α597')) <! getOr605'    (0)
//│ | | | NEW getOr605' LB (1)
//│ | Completed TypedNuFun(0,fun getOr = (x::13, d::14,) => if x is ‹(None) then d; (Some(g,)) then g›,((x591', d592',) -> (α593' | α597'))) where 
//│ 		x591' <: (#None<Object,Option> | ((#Some<Object,Option> & {Some#A: mut A576_594'..A576_595'}) & ~(#None<Object,Option>))) & Object
//│ 		d592' <: α593'
//│ 		A576_594' <: A576_595'
//│ 		α597' :> (⊤(‘A596'') & A576_595')
//│ | Typing unit statements
//│ | : None
//│ ======== TYPED ========
//│ fun getOr: ‹∀ 0. ((x591', d592',) -> (α593' | α597'))› where 
//│ |		x591' <: (#None<Object,Option> | ((#Some<Object,Option> & {Some#A: mut A576_594'..A576_595'}) & ~(#None<Object,Option>))) & Object
//│ |		d592' <: α593'
//│ |		A576_594' <: A576_595'
//│ |		α597' :> (⊤(‘A596'') & A576_595')
//│ fun getOr: forall 'A 'a. (None | Some['A], 'a) -> (??A & 'A | 'a)

fun getOr(x: Option['a], d) = if x is
    None then d
    Some(g) then g
//│ fun getOr: forall 'a 'b. (x: Option['a], 'b) -> (??A & 'a | 'b)

fun getOr[T](x: Option[T], d: T): T = if x is
    None then d
    Some(g) then g
//│ fun getOr: forall 'T. (x: Option['T], d: 'T) -> 'T

fun get(x) = if x is Some(r) then r else error
//│ fun get: forall 'A. (Object & ~#Some | Some['A]) -> (??A & 'A)

fun get(x: Option['a]): x.T = if x is Some(r) then r else error
//│ fun get: forall 'a. (x: Option['a]) -> 'a

