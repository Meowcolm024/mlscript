:NewParser
:NewDefs

fun (++) concatOp(a, b) = concat(a)(b)
//│ fun (++) concatOp: (Str, Str) -> Str

fun par(a) = "(" ++ a ++ ")"
//│ fun par: Str -> Str

type Option[A] = Some[A] | None
class Some[A](value: A)
module None
//│ type Option[A] = None | Some[A]
//│ class Some[A](value: A)
//│ module None

type Result[A, B] = Ok[A] | Err[B]
class Ok[A](value: A)
class Err[A](message: A)
//│ type Result[A, B] = Err[B] | Ok[A]
//│ class Ok[A](value: A)
//│ class Err[A](message: A)

type Type = FunctionType | PrimitiveType
class PrimitiveType(name: Str)
class FunctionType(lhs: Type, rhs: Type)
//│ type Type = FunctionType | PrimitiveType
//│ class PrimitiveType(name: Str)
//│ class FunctionType(lhs: Type, rhs: Type)

// Helpers.
fun _f(lhs, rhs) = FunctionType(lhs, rhs)
fun _t(name) = PrimitiveType(name)
//│ fun _f: (Type, Type) -> FunctionType
//│ fun _t: Str -> PrimitiveType

type Term = Lit | Var | Abs | App
class Lit(tag: Str, ty: Type)
class Var(name: Str)
class Abs(lhs: Var, lty: Type, rhs: Term)
class App(lhs: Term, rhs: Term)
// class App(lhs: Term, rhs: Term): Term
//│ type Term = Abs | App | Lit | Var
//│ class Lit(tag: Str, ty: Type)
//│ class Var(name: Str)
//│ class Abs(lhs: Var, lty: Type, rhs: Term)
//│ class App(lhs: Term, rhs: Term)

type TreeMap[A] = Node[A] | Empty
class Node[A](key: Str, value: A, left: TreeMap[A], right: TreeMap[A])
module Empty
//│ type TreeMap[A] = Empty | Node[A]
//│ class Node[A](key: Str, value: A, left: TreeMap[A], right: TreeMap[A])
//│ module Empty

fun insert(t, k, v) =
  if t is
    Node(k', _, l, r) and
      slt(k, k') then Node(k', v, insert(l, k, v), r)
      sgt(k, k') then Node(k', v, l, insert(r, k, v))
      _ then Node(k, v, l, r)
    Empty then Node(k, v, Empty, Empty)
fun find(t, k) =
  if t is
    Node(k', v, l, r) and
      slt(k, k') then find(l, k)
      sgt(k, k') then find(r, k)
      _ then Some(v)
    Empty then None
//│ fun insert: forall 'A 'A0 'A1 'A2 'A3 'A4. (Empty | Node[in 'A2 out 'A1], Str, 'A0) -> Node[in 'A out 'A4]
//│ fun find: forall 'A5. (Empty | Node[in 'A5 out nothing], Str) -> (None | Some[??A & 'A5])
//│ where
//│   'A2 <: 'A0 & 'A3 & ('A1 & ('A | ~??A0) | ??A1 & ('A | ~??A0)) | ~??A0
//│   'A0 <: 'A & 'A3 & ('A1 | ??A1)
//│   'A :> 'A4 | ??A0 & 'A2
//│      <: 'A0 & 'A3 & ('A1 | ??A1)
//│   'A4 :> 'A | ??A0 & 'A2 | 'A3
//│   'A3 :> 'A4 | ??A0 & 'A2
//│       <: 'A0 & 'A & ('A1 | ??A1)
//│   'A1 <: 'A2

fun showType(ty) =
  if ty is
    FunctionType(PrimitiveType(name), rhs) then name ++ " -> " ++ showType(rhs)
    FunctionType(lhs, rhs) then "(" ++ showType(lhs) ++ ") -> " ++ showType(rhs)
    PrimitiveType(name) then name
//│ fun showType: (FunctionType | PrimitiveType) -> Str

showType(_t("int"))
showType(_f(_t("int"), _t("bool")))
showType(_f(_f(_t("int"), _t("bool")), _t("bool")))
showType(_f(_t("bool"), _f(_t("int"), _t("bool"))))
//│ Str
//│ res
//│     = 'int'
//│ res
//│     = 'int -> bool'
//│ res
//│     = '(int -> bool) -> bool'
//│ res
//│     = 'bool -> int -> bool'

fun typeEqual(t1, t2) =
  if
    t1 is PrimitiveType(name1) and t2 is PrimitiveType(name2) then eq(name1)(name2)
    t1 is FunctionType(lhs1, rhs1) and t2 is FunctionType(lhs2, rhs2) then
      typeEqual(lhs1, lhs2) and typeEqual(rhs1, rhs2)
    _ then false
//│ fun typeEqual: (Object, Object) -> Bool

fun showTerm(t) =
  if t is
    Lit(tag, _) then tag
    Var(name) then name
    Abs(lhs, ty, rhs) then "&" ++ showTerm(lhs) ++ ": " ++ showType(ty) ++ " => " ++ showTerm(rhs)
    App(Abs(lhs0, ty, lhs1), rhs) then
      "((" ++ showTerm(Abs(lhs0, ty, rhs)) ++ ") " ++ showTerm(rhs) ++ ")"
    App(lhs, rhs) then par(showTerm(lhs) ++ " " ++ showTerm(rhs))
//│ fun showTerm: (Abs | App | Lit | Var) -> Str

showTerm(Var("x"))
showTerm(Abs(Var("x"), _t("int"), Var("y")))
showTerm(App(Var("x"), Var("y")))
showTerm(App(Abs(Var("x"), _t("int"), Var("y")), Var("z")))
//│ Str
//│ res
//│     = 'x'
//│ res
//│     = '&x: int => y'
//│ res
//│     = '(x y)'
//│ res
//│     = '((&x: int => z) z)'

:e // FIXME recursion depth excess
// Removing the return type annotation causes stack overflow.
fun typeTerm(t: Term, ctx: TreeMap[Type]): Result[Type, Str] =
  if t is
    Lit(_, ty) then Ok(ty)
    Var(name) and find(ctx, name) is
      Some(ty) then Ok(ty)
      None then Err("unbound variable `" ++ name ++ "`")
    Abs(Var(name), ty, body) and typeTerm(body, insert(ctx, name, ty)) is
      Ok(resTy) then Ok(FunctionType(ty, resTy))
      Err(message) then Err(message)
    App(lhs, rhs) and typeTerm(lhs, ctx) is
      Ok(FunctionType(pTy, resTy)) and typeTerm(rhs, ctx) is
        Ok(aTy) and
          typeEqual(pTy, aTy) then Ok(resTy)
          else Err("expect the argument to be of type `" ++ showType(pTy) ++ "` but found `" ++ showType(aTy) ++ "`")
        Err(message) then Err(message)
      Ok(PrimitiveType(name)) then Err("cannot apply primitive type `" ++ name ++ "`")
      Err(message) then Err(message)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.143: 	    Abs(Var(name), ty, body) and typeTerm(body, insert(ctx, name, ty)) is
//│ ║         	                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `~??A` does not match type `FunctionType | PrimitiveType`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.24: 	type Type = FunctionType | PrimitiveType
//│ ║        	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.137: 	fun typeTerm(t: Term, ctx: TreeMap[Type]): Result[Type, Str] =
//│ ║         	                                   ^^^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.50: 	class Node[A](key: Str, value: A, left: TreeMap[A], right: TreeMap[A])
//│ ╙──      	           ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.143: 	    Abs(Var(name), ty, body) and typeTerm(body, insert(ctx, name, ty)) is
//│ ║         	                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.144: 	      Ok(resTy) then Ok(FunctionType(ty, resTy))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `A & ?A` does not match type `FunctionType | PrimitiveType`
//│ ║  l.18: 	class Ok[A](value: A)
//│ ║        	            ^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.24: 	type Type = FunctionType | PrimitiveType
//│ ║        	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.144: 	      Ok(resTy) then Ok(FunctionType(ty, resTy))
//│ ╙──       	                                         ^^^^^
//│ ╔══[ERROR] Subtyping constraint of the form `([?a, ?b, ?c]) -> ?d <: ?e -> ?f` exceeded recursion depth limit (250)
//│ ║  l.138: 	  if t is
//│ ║         	     ^^^^
//│ ║  l.139: 	    Lit(_, ty) then Ok(ty)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.140: 	    Var(name) and find(ctx, name) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.141: 	      Some(ty) then Ok(ty)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.142: 	      None then Err("unbound variable `" ++ name ++ "`")
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.143: 	    Abs(Var(name), ty, body) and typeTerm(body, insert(ctx, name, ty)) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.144: 	      Ok(resTy) then Ok(FunctionType(ty, resTy))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.145: 	      Err(message) then Err(message)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.147: 	      Ok(FunctionType(pTy, resTy)) and typeTerm(rhs, ctx) is
//│ ║         	                                       ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.148: 	        Ok(aTy) and
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ║  l.149: 	          typeEqual(pTy, aTy) then Ok(resTy)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.150: 	          else Err("expect the argument to be of type `" ++ showType(pTy) ++ "` but found `" ++ showType(aTy) ++ "`")
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `A & ?A` does not match type `FunctionType | PrimitiveType`
//│ ║  l.18: 	class Ok[A](value: A)
//│ ║        	            ^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.83: 	  if ty is
//│ ║        	     ^^
//│ ╟── from reference:
//│ ║  l.150: 	          else Err("expect the argument to be of type `" ++ showType(pTy) ++ "` but found `" ++ showType(aTy) ++ "`")
//│ ╙──       	                                                                                                         ^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.146: 	    App(lhs, rhs) and typeTerm(lhs, ctx) is
//│ ║         	                      ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.147: 	      Ok(FunctionType(pTy, resTy)) and typeTerm(rhs, ctx) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.148: 	        Ok(aTy) and
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ║  l.149: 	          typeEqual(pTy, aTy) then Ok(resTy)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.150: 	          else Err("expect the argument to be of type `" ++ showType(pTy) ++ "` but found `" ++ showType(aTy) ++ "`")
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.151: 	        Err(message) then Err(message)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.152: 	      Ok(PrimitiveType(name)) then Err("cannot apply primitive type `" ++ name ++ "`")
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `A & ?A` does not match type `FunctionType | PrimitiveType`
//│ ║  l.18: 	class Ok[A](value: A)
//│ ║        	            ^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.147: 	      Ok(FunctionType(pTy, resTy)) and typeTerm(rhs, ctx) is
//│ ╙──       	         ^^^^^^^^^^^^^^^^^^^^^^^^
//│ fun typeTerm: (t: Term, ctx: TreeMap[Type]) -> Result[Type, Str]

fun showTypeTerm(t, ctx) =
  if typeTerm(t, ctx) is
    Ok(ty) then showTerm(t) ++ " : " ++ showType(ty)
    Err(message) then "Type error: " ++ message
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.241: 	  if typeTerm(t, ctx) is
//│ ║         	     ^^^^^^^^^^^^^^^^^^^
//│ ║  l.242: 	    Ok(ty) then showTerm(t) ++ " : " ++ showType(ty)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `A & ?A` does not match type `FunctionType | PrimitiveType`
//│ ║  l.18: 	class Ok[A](value: A)
//│ ║        	            ^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.83: 	  if ty is
//│ ║        	     ^^
//│ ╟── from reference:
//│ ║  l.242: 	    Ok(ty) then showTerm(t) ++ " : " ++ showType(ty)
//│ ╙──       	                                                 ^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.241: 	  if typeTerm(t, ctx) is
//│ ║         	     ^^^^^^^^^^^^^^^^^^^
//│ ║  l.242: 	    Ok(ty) then showTerm(t) ++ " : " ++ showType(ty)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.243: 	    Err(message) then "Type error: " ++ message
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `A & ?A` is not an instance of type `Str`
//│ ║  l.19: 	class Err[A](message: A)
//│ ║        	             ^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.4: 	fun (++) concatOp(a, b) = concat(a)(b)
//│ ║       	                                    ^
//│ ╟── from reference:
//│ ║  l.243: 	    Err(message) then "Type error: " ++ message
//│ ╙──       	                                        ^^^^^^^
//│ fun showTypeTerm: (Term, TreeMap[Type]) -> (Str | error)

:e // FIXME recursion depth excess
showTypeTerm(Var("x"), Empty)
showTypeTerm(Abs(Var("x"), _t("int"), Var("x")), Empty)
showTypeTerm(App(Var("f"), Lit("0", _t("int"))), insert(Empty, "f", _f(_t("int"), _t("int"))))
showTypeTerm(App(Var("f"), Lit("0.2", _t("float"))), insert(Empty, "f", _f(_t("int"), _t("int"))))
showTypeTerm(App(Var("f"), Lit("0", _t("int"))), insert(Empty, "f", _t("Str")))
//│ Str | error
//│ res
//│     = 'Type error: unbound variable `x`'
//│ res
//│     = '&x: int => x : int -> int'
//│ res
//│     = '(f 0) : int'
//│ res
//│     = 'Type error: expect the argument to be of type `int` but found `float`'
//│ res
//│     = 'Type error: cannot apply primitive type `Str`'

