:NewDefs



:escape
let nothing: nothing
//│ let nothing: nothing
//│ nothing
//│         = <missing implementation>

module None {
  fun value = nothing
}
class Some[out A](val value: A)
//│ module None {
//│   fun value: nothing
//│ }
//│ class Some[A](value: A)

type List[out A] = Cons[A] | Nil
module Nil {
  fun toArray = []
}
class Cons[out A](val head: A, val tail: List[A]) {
  fun toArray: Array[anything]
  fun toArray = [head, tail.toArray]
}
//│ type List[A] = Cons[A] | Nil
//│ module Nil {
//│   fun toArray: []
//│ }
//│ class Cons[A](head: A, tail: List[A]) {
//│   fun toArray: Array[anything]
//│ }

fun pairup(x, y) = [x, y]
//│ fun pairup: forall 'a 'b. ('a, 'b) -> ['a, 'b]



// FIXME parsing
fun zipWith_wrong(f, xs, ys) =
  if  xs is Cons(x, xs)
  and ys is Cons(y, ys)
  and zipWith_wrong(f, xs, ys) is Some(tail)
  then Some(Cons(f(x, y), tail))
  else None
//│ ╔══[PARSE ERROR] Expected 'then'/'else' clause after 'if'; found operator application followed by newline instead
//│ ║  l.43: 	  if  xs is Cons(x, xs)
//│ ║        	      ^^^^^^^^^^^^^^^^^
//│ ║  l.44: 	  and ys is Cons(y, ys)
//│ ║        	^^
//│ ╟── Note: 'if' expression starts here:
//│ ║  l.43: 	  if  xs is Cons(x, xs)
//│ ╙──      	  ^^
//│ ╔══[PARSE ERROR] Unexpected operator in expression position
//│ ║  l.44: 	  and ys is Cons(y, ys)
//│ ╙──      	  ^^^
//│ ╔══[PARSE ERROR] Unexpected operator in expression position
//│ ║  l.45: 	  and zipWith_wrong(f, xs, ys) is Some(tail)
//│ ╙──      	  ^^^
//│ ╔══[PARSE ERROR] Expected an expression; found a 'then'/'else' clause instead
//│ ║  l.43: 	  if  xs is Cons(x, xs)
//│ ║        	      ^^^^^^^^^^^^^^^^^
//│ ║  l.44: 	  and ys is Cons(y, ys)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.45: 	  and zipWith_wrong(f, xs, ys) is Some(tail)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.46: 	  then Some(Cons(f(x, y), tail))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.47: 	  else None
//│ ╙──      	^^^^^^^^^^^
//│ fun zipWith_wrong: (anything, anything, anything) -> ()


// FIXME parsing
fun zipWith_wrong(f, xs, ys) =
  if  xs is Cons(x, xs)
    and ys is Cons(y, ys)
    and zipWith_wrong(f, xs, ys) is Some(tail) then Some(Cons(f(x, y), tail))
  else None
//│ ╔══[ERROR] illegal pattern
//│ ║  l.78: 	  if  xs is Cons(x, xs)
//│ ║        	            ^^^^^^^^^^^
//│ ║  l.79: 	    and ys is Cons(y, ys)
//│ ╙──      	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ fun zipWith_wrong: (anything, anything, anything) -> error
//│ Code generation encountered an error:
//│   if expression was not desugared


fun zipWith_wrong(f, xs, ys) =
  if  xs is Cons(x, xs)
    and ys is Cons(y, ys) and zipWith_wrong(f, xs, ys) is Some(tail) then Some(Cons(f(x, y), tail))
  else None
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.94: 	    and ys is Cons(y, ys) and zipWith_wrong(f, xs, ys) is Some(tail) then Some(Cons(f(x, y), tail))
//│ ║        	                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `A & ?A` does not match type `Cons[?A0] | Nil`
//│ ║  l.14: 	class Some[out A](val value: A)
//│ ║        	                      ^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.20: 	type List[out A] = Cons[A] | Nil
//│ ║        	                   ^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.94: 	    and ys is Cons(y, ys) and zipWith_wrong(f, xs, ys) is Some(tail) then Some(Cons(f(x, y), tail))
//│ ╙──      	                                                                                             ^^^^
//│ fun zipWith_wrong: forall 'A 'A0 'a. ((??A & 'A, ??A0 & 'A0) -> 'a, Cons['A] | Object & ~#Cons, Cons['A0] | Object & ~#Cons) -> (None | Some[Cons[error | 'a]] | error)

// * Notice the result is wrong (duh)
zipWith_wrong(pairup, Nil, Nil)
//│ None | Some[Cons[error | [nothing, nothing]]] | error
//│ res
//│     = None { class: [class None] }



fun zipWith(f, xs, ys) =
  if xs is
    Cons(x, xs) and ys is Cons(y, ys) and zipWith(f, xs, ys) is Some(tail) then Some(Cons(f(x, y), tail))
    Nil and ys is Nil then Some(Nil)
  else None
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.120: 	    Cons(x, xs) and ys is Cons(y, ys) and zipWith(f, xs, ys) is Some(tail) then Some(Cons(f(x, y), tail))
//│ ║         	                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `A & ?A` does not match type `Cons[?A0] | Nil`
//│ ║  l.14: 	class Some[out A](val value: A)
//│ ║        	                      ^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.20: 	type List[out A] = Cons[A] | Nil
//│ ║        	                   ^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.120: 	    Cons(x, xs) and ys is Cons(y, ys) and zipWith(f, xs, ys) is Some(tail) then Some(Cons(f(x, y), tail))
//│ ╙──       	                                                                                                   ^^^^
//│ fun zipWith: forall 'A 'A0 'a. ((??A & 'A, ??A0 & 'A0) -> 'a, Cons['A] | Object & ~#Cons, Cons['A0] | Object & ~#Cons) -> (None | Some[Cons[error | 'a] | Nil] | error)

zipWith(pairup, Cons(0, Nil), Cons("0", Nil)).value.toArray
//│ error | Array[anything]
//│ res
//│     = [ [ 0, '0' ], [] ]


fun zipWith(f, xs, ys) =
  if xs is
    Cons(x, xs) and ys is Cons(y, ys) and zipWith(f, xs, ys) is Some(tail) then Some(Cons(f(x, y), tail))
    Nil and ys is Nil then Some(Nil)
  else None
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.145: 	    Cons(x, xs) and ys is Cons(y, ys) and zipWith(f, xs, ys) is Some(tail) then Some(Cons(f(x, y), tail))
//│ ║         	                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `A & ?A` does not match type `Cons[?A0] | Nil`
//│ ║  l.14: 	class Some[out A](val value: A)
//│ ║        	                      ^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.20: 	type List[out A] = Cons[A] | Nil
//│ ║        	                   ^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.145: 	    Cons(x, xs) and ys is Cons(y, ys) and zipWith(f, xs, ys) is Some(tail) then Some(Cons(f(x, y), tail))
//│ ╙──       	                                                                                                   ^^^^
//│ fun zipWith: forall 'A 'A0 'a. ((??A & 'A, ??A0 & 'A0) -> 'a, Cons['A] | Object & ~#Cons, Cons['A0] | Object & ~#Cons) -> (None | Some[Cons[error | 'a] | Nil] | error)

zipWith(pairup, Cons(0, Nil), Cons("0", Nil)).value.toArray
//│ error | Array[anything]
//│ res
//│     = [ [ 0, '0' ], [] ]


fun zipWith(f, xs, ys) =
  if xs is Cons(x, xs) and ys is Cons(y, ys) and zipWith(f, xs, ys) is Some(tail) then Some(Cons(f(x, y), tail))
  else if xs is Nil and ys is Nil then Some(Nil)
  else None
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.169: 	  if xs is Cons(x, xs) and ys is Cons(y, ys) and zipWith(f, xs, ys) is Some(tail) then Some(Cons(f(x, y), tail))
//│ ║         	                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `A & ?A` does not match type `Cons[?A0] | Nil`
//│ ║  l.14: 	class Some[out A](val value: A)
//│ ║        	                      ^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.20: 	type List[out A] = Cons[A] | Nil
//│ ║        	                   ^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.169: 	  if xs is Cons(x, xs) and ys is Cons(y, ys) and zipWith(f, xs, ys) is Some(tail) then Some(Cons(f(x, y), tail))
//│ ╙──       	                                                                                                          ^^^^
//│ fun zipWith: forall 'A 'A0 'a. ((??A & 'A, ??A0 & 'A0) -> 'a, Cons['A] | Object & ~#Cons, Cons['A0] | Object & ~#Cons) -> (None | Some[Cons[error | 'a] | Nil] | error)

zipWith(pairup, Cons(0, Nil), Cons("0", Nil)).value.toArray
//│ error | Array[anything]
//│ res
//│     = [ [ 0, '0' ], [] ]


fun zipWith(f, xs, ys) =
  if xs is Cons(x, xs) and ys is Cons(y, ys) then
    if zipWith(f, xs, ys) is Some(tail) then Some(Cons(f(x, y), tail))
    else None
  else if xs is Nil and ys is Nil then Some(Nil)
  else None
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.194: 	    if zipWith(f, xs, ys) is Some(tail) then Some(Cons(f(x, y), tail))
//│ ║         	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `A & ?A` does not match type `Cons[?A0] | Nil`
//│ ║  l.14: 	class Some[out A](val value: A)
//│ ║        	                      ^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.20: 	type List[out A] = Cons[A] | Nil
//│ ║        	                   ^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.194: 	    if zipWith(f, xs, ys) is Some(tail) then Some(Cons(f(x, y), tail))
//│ ╙──       	                                                                ^^^^
//│ fun zipWith: forall 'A 'A0 'a. ((??A & 'A, ??A0 & 'A0) -> 'a, Cons['A] | Object & ~#Cons, Cons['A0] | Object & ~#Cons) -> (None | Some[Cons[error | 'a] | Nil] | error)

zipWith(pairup, Cons(0, Nil), Cons("0", Nil)).value.toArray
//│ error | Array[anything]
//│ res
//│     = [ [ 0, '0' ], [] ]


fun zipWith(f, xs, ys) =
  if xs is
    Cons(x, xs) then
      if ys is
        Cons(y, ys) then
          if zipWith(f, xs, ys) is
            Some(tail) then Some(Cons(f(x, y), tail))
            None then None
        Nil then None
    Nil then
      if ys is Nil then Some(Nil) else None
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.223: 	          if zipWith(f, xs, ys) is
//│ ║         	             ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.224: 	            Some(tail) then Some(Cons(f(x, y), tail))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `A & ?A` does not match type `Cons[?A0] | Nil`
//│ ║  l.14: 	class Some[out A](val value: A)
//│ ║        	                      ^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.20: 	type List[out A] = Cons[A] | Nil
//│ ║        	                   ^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.224: 	            Some(tail) then Some(Cons(f(x, y), tail))
//│ ╙──       	                                               ^^^^
//│ fun zipWith: forall 'A 'A0 'a. ((??A & 'A, ??A0 & 'A0) -> 'a, Cons['A] | Nil, Cons['A0] | Nil) -> (None | Some[Cons[error | 'a] | Nil] | error)

zipWith(pairup, Nil, Nil).value.toArray
//│ error | Array[anything]
//│ res
//│     = []

:re
zipWith(pairup, Nil, Cons(0, Nil)).value.toArray
//│ error | Array[anything]
//│ res
//│ Runtime error:
//│   ReferenceError: nothing is not defined

zipWith(pairup, Cons(0, Nil), Cons("0", Nil)).value.toArray
//│ error | Array[anything]
//│ res
//│     = [ [ 0, '0' ], [] ]

let ls = zipWith(pairup, Cons(0, Cons(1, Nil)), Cons("0", Cons("1", Nil)))
ls.value.toArray
//│ let ls: None | Some[Cons[error | [??A & (0 | 1), ??A0 & ("0" | "1")]] | Nil] | error
//│ error | Array[anything]
//│ ls
//│    = Some {}
//│ res
//│     = [ [ 0, '0' ], [ [ 1, '1' ], [] ] ]



fun zipWith_wrong2(f, xs, ys) =
  if xs is Cons(x, xs) and ys is Cons(y, ys) and zipWith_wrong2(f, xs, ys) is Some(tail) then Cons(Some(f(x, y)), tail)
  else if xs is Nil and ys is Nil then Some(Nil)
  else None
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.274: 	  if xs is Cons(x, xs) and ys is Cons(y, ys) and zipWith_wrong2(f, xs, ys) is Some(tail) then Cons(Some(f(x, y)), tail)
//│ ║         	                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `A & ?A` does not match type `Cons[?A0] | Nil`
//│ ║  l.14: 	class Some[out A](val value: A)
//│ ║        	                      ^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.20: 	type List[out A] = Cons[A] | Nil
//│ ║        	                   ^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.274: 	  if xs is Cons(x, xs) and ys is Cons(y, ys) and zipWith_wrong2(f, xs, ys) is Some(tail) then Cons(Some(f(x, y)), tail)
//│ ╙──       	                                                                                                                  ^^^^
//│ fun zipWith_wrong2: forall 'A 'A0 'a. ((??A & 'A, ??A0 & 'A0) -> 'a, Cons['A] | Object & ~#Cons, Cons['A0] | Object & ~#Cons) -> (Cons[Some['a] | error] | None | Some[Nil] | error)

// * No type error! The definition and use are well-typed...
zipWith_wrong2(pairup, Cons(0, Cons(1, Nil)), Cons("0", Cons("1", Nil)))
//│ Cons[Some[[??A & (0 | 1), ??A0 & ("0" | "1")]] | error] | None | Some[Nil] | error
//│ res
//│     = None { class: [class None] }


