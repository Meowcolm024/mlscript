:NewDefs


class Numb(n: Int)
//│ class Numb(n: Int)


// * FIXME should be rejected
fun process(e) =
  if e is
    Numb(n) and n > 0 then n
    Numb(m) then n
//│ fun process: Numb -> Int

process(Numb(-10))
//│ Int
//│ res
//│     = -10


// * FIXME wrong result
fun process(e, n) =
  if e is
    Numb(n) and n > 0 then n
    Numb(m) then n + m
//│ fun process: (Numb, anything) -> Int

process(Numb(0), 10)
//│ Int
//│ res
//│     = 0


class Vec(xs: Array[Numb | Vec])
class Pair[A,B](a: A, b: B)
//│ class Vec(xs: Array[Numb | Vec])
//│ class Pair[A, B](a: A, b: B)

// * FIXME should be rejected
fun process(e) =
  if e is
    Pair(Numb(n), Numb(m)) then Numb(n + m)
    Pair(Vec(xs), Vec(ys))  then n
    Pair(Vec(n),  Numb(n)) then n
    Pair(Numb(n), Vec(n))  then n
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.41: 	  if e is
//│ ║        	     ^^^^
//│ ║  l.42: 	    Pair(Numb(n), Numb(m)) then Numb(n + m)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.43: 	    Pair(Vec(xs), Vec(ys))  then n
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.44: 	    Pair(Vec(n),  Numb(n)) then n
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.45: 	    Pair(Numb(n), Vec(n))  then n
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `A & ?A` does not match type `Numb | Vec`
//│ ║  l.35: 	class Pair[A,B](a: A, b: B)
//│ ║        	                ^
//│ ╟── Note: constraint arises from application:
//│ ║  l.42: 	    Pair(Numb(n), Numb(m)) then Numb(n + m)
//│ ╙──      	         ^^^^^^^
//│ fun process: Pair[anything, anything] -> error


// * FIXME should warn, be rejected, or compare both values for equality
fun process(e) =
  if e is
    Pair(Numb(n), Numb(n)) then n
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.68: 	  if e is
//│ ║        	     ^^^^
//│ ║  l.69: 	    Pair(Numb(n), Numb(n)) then n
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `A & ?A` is not an instance of type `Numb`
//│ ║  l.35: 	class Pair[A,B](a: A, b: B)
//│ ║        	                ^
//│ ╟── Note: constraint arises from class pattern:
//│ ║  l.69: 	    Pair(Numb(n), Numb(n)) then n
//│ ║        	         ^^^^
//│ ╟── from application:
//│ ║  l.69: 	    Pair(Numb(n), Numb(n)) then n
//│ ╙──      	         ^^^^^^^
//│ fun process: Pair[anything, anything] -> error

process(Pair(Numb(1), Numb(2)))
//│ error
//│ res
//│     = 2


