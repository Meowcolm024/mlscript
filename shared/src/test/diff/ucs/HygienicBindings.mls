:NewDefs

type Option[out T] = None | Some[T]
module None
class Some[out T](val value: T)
//│ type Option[T] = None | Some[T]
//│ module None
//│ class Some[T](value: T)

type Either[A, B] = Left[A] | Right[B]
class Left[A](val leftValue: A)
class Right[B](val rightValue: B)
//│ type Either[A, B] = Left[A] | Right[B]
//│ class Left[A](leftValue: A)
//│ class Right[B](rightValue: B)

type List[out A] = Nil | Cons[A]
module Nil
class Cons[out A](head: A, tail: List[A])
//│ type List[A] = Cons[A] | Nil
//│ module Nil
//│ class Cons[A](head: A, tail: List[A])

fun h0(a) =
  if
    a is Some(Left(y)) then y
    a is Some(Right(z)) then z
    a is None then 0
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.26: 	    a is Some(Left(y)) then y
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.27: 	    a is Some(Right(z)) then z
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `T & ?T` does not match type `Left[?A] | Right[?B]`
//│ ║  l.5: 	class Some[out T](val value: T)
//│ ║       	                      ^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.26: 	    a is Some(Left(y)) then y
//│ ╙──      	              ^^^^^^^
//│ fun h0: (None | Some[anything]) -> (0 | error)

// FIXME: Precise scrutinee identification (easy)
// This seems fine. But the subtrees are not merged.
fun h1(a) =
  if
    a is Some(x) and x is Left(y) then y
    a is Some(y) and y is Right(z) then z
    a is None then 0
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.46: 	    a is Some(x) and x is Left(y) then y
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.47: 	    a is Some(y) and y is Right(z) then z
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `T & ?T` is not an instance of type `Right`
//│ ║  l.5: 	class Some[out T](val value: T)
//│ ║       	                      ^^^^^
//│ ╟── Note: constraint arises from class pattern:
//│ ║  l.47: 	    a is Some(y) and y is Right(z) then z
//│ ║        	                          ^^^^^
//│ ╟── from reference:
//│ ║  l.47: 	    a is Some(y) and y is Right(z) then z
//│ ╙──      	                     ^
//│ fun h1: (None | Some[anything]) -> (0 | error)

// This is the desugared version of the test case above.
fun h1'(a) =
  if a is
    Some then
      let x = a.value
      let y = a.value
      if x is
        Left then
          let y = x.leftValue
          y
        _ then
          if y is
            Right then
              let z = y.rightValue
              z
    None then 0
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.71: 	      if x is
//│ ║        	         ^^^^
//│ ║  l.72: 	        Left then
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ║  l.73: 	          let y = x.leftValue
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.74: 	          y
//│ ║        	^^^^^^^^^^^
//│ ║  l.75: 	        _ then
//│ ║        	^^^^^^^^^^^^^^
//│ ║  l.76: 	          if y is
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ║  l.77: 	            Right then
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.78: 	              let z = y.rightValue
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.79: 	              z
//│ ║        	^^^^^^^^^^^^^^^
//│ ╟── field selection of type `T & ?T` is not an instance of type `Object`
//│ ║  l.69: 	      let x = a.value
//│ ║        	              ^^^^^^^
//│ ╟── but it flows into reference with expected type `Object`
//│ ║  l.71: 	      if x is
//│ ╙──      	         ^
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.76: 	          if y is
//│ ║        	             ^^^^
//│ ║  l.77: 	            Right then
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.78: 	              let z = y.rightValue
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.79: 	              z
//│ ║        	^^^^^^^^^^^^^^^
//│ ╟── field selection of type `T & ?T` is not an instance of type `Object`
//│ ║  l.70: 	      let y = a.value
//│ ║        	              ^^^^^^^
//│ ╟── but it flows into reference with expected type `Object`
//│ ║  l.76: 	          if y is
//│ ╙──      	             ^
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.76: 	          if y is
//│ ║        	             ^^^^
//│ ║  l.77: 	            Right then
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.78: 	              let z = y.rightValue
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.79: 	              z
//│ ║        	^^^^^^^^^^^^^^^
//│ ╟── field selection of type `T & ?T` is not an instance of type `Right`
//│ ║  l.70: 	      let y = a.value
//│ ║        	              ^^^^^^^
//│ ╟── but it flows into reference with expected type `Right[anything]`
//│ ║  l.76: 	          if y is
//│ ║        	             ^
//│ ╟── Note: constraint arises from class pattern:
//│ ║  l.77: 	            Right then
//│ ╙──      	            ^^^^^
//│ fun h1': (None | Some[anything]) -> (0 | error | ??A & ??A0)

// FIXME This seems fine but the desugared term does not merge the cases.
// See the example below.
fun h1''(a) =
  if
    a is Some(x) and x is Left(y) then y
    a is Some(x) and x is Right(z) then z
    a is None then 0
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.145: 	    a is Some(x) and x is Left(y) then y
//│ ║         	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.146: 	    a is Some(x) and x is Right(z) then z
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `T & ?T` does not match type `Left[?A] | Right[?B]`
//│ ║  l.5: 	class Some[out T](val value: T)
//│ ║       	                      ^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.145: 	    a is Some(x) and x is Left(y) then y
//│ ╙──       	                     ^
//│ fun h1'': (None | Some[anything]) -> (0 | error)

// FIXME
h1(Some(Left(0)))
h1'(Some(Left(0)))
h1''(Some(Left(0)))
//│ 0 | error
//│ res
//│     = 0
//│ res
//│     = 0
//│ res
//│     = 0

// FIXME: Precise scrutinee identification (hard)
fun h2(a) =
  if
    a is Some(x) and x is x' and x' is Left(y) then y
    a is Some(y) and
      let y' = y
      y' is Right(z) then z
    a is None then 0
//│ ╔══[ERROR] identifier not found: y
//│ ║  l.178: 	      let y' = y
//│ ╙──       	               ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.176: 	    a is Some(x) and x is x' and x' is Left(y) then y
//│ ║         	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.177: 	    a is Some(y) and
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.178: 	      let y' = y
//│ ║         	^^^^^^^^^^^^^^^^
//│ ║  l.179: 	      y' is Right(z) then z
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── field selection of type `T & ?T` is not an instance of type `Object`
//│ ║  l.5: 	class Some[out T](val value: T)
//│ ║       	                      ^^^^^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.176: 	    a is Some(x) and x is x' and x' is Left(y) then y
//│ ║         	                                 ^^^^^^^^^^^^^^^^^^^^
//│ ║  l.177: 	    a is Some(y) and
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.178: 	      let y' = y
//│ ║         	^^^^^^^^^^^^^^^^
//│ ║  l.179: 	      y' is Right(z) then z
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.176: 	    a is Some(x) and x is x' and x' is Left(y) then y
//│ ╙──       	                     ^
//│ ╔══[ERROR] identifier not found: y
//│ ║  l.178: 	      let y' = y
//│ ╙──       	               ^
//│ fun h2: (None | Some[anything]) -> (0 | error | ??A & ??A0)
//│ Code generation encountered an error:
//│   unresolved symbol y

// FIXME: Some results are wrong.
fun h3(x, y, f, p) =
  if x is
    _ and f(x) is y and p(x) then y
    None then y
    _ then "anyway"
h3("anything", "not me", _ => "should be me", _ => true)
h3(None, "should be me", _ => "not me", _ => false)
h3("anything", "anything", _ => "not me", _ => false)
//│ fun h3: forall 'a 'b. (None | Object & 'a & ~#None, 'b, (None | 'a) -> anything, (None | 'a) -> Object) -> ("anyway" | 'b)
//│ "anything" | "anyway"
//│ res
//│     = 'not me'
//│ res
//│     = 'should be me'
//│ res
//│     = 'anyway'

// FIXME: Some results are wrong.
fun h4(x, y, p) =
  if x is
    y and p(x) then y
    None then y
    _ then "default"
h4("should be me", "not me", _ => true) // WRONG!
h4(None, "not me", _ => true) // WRONG!
h4(None, "should be me", _ => false)
h4("anything", "not me", _ => false)
//│ fun h4: forall 'a 'b. (None | Object & 'a & ~#None, 'b, (None | 'a) -> Object) -> ("default" | 'b)
//│ "default" | "not me"
//│ res
//│     = 'not me'
//│ res
//│     = 'not me'
//│ res
//│     = 'should be me'
//│ res
//│     = 'default'
