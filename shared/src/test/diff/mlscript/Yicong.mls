
trait T1
trait T2
//│ Defined trait T1
//│ Defined trait T2

r = if true then T1 ((1,2,3)) else T2 ((3,4,5,4))
//│ r: (1, 2, 3,) & t1 | (3, 4, 5, 4,) & t2
//│  = [ 1, 2, 3 ]

// FIXME
case r of { T1 -> r | _ -> 0 }
//│ res: (1, 2, 3,) & t1 | (3, 4, 5, 4,) & t1 & t2 | 0
//│ Runtime error:
//│   ReferenceError: T1 is not defined

// FIXME
case r of { T1 -> r | T2 -> r }
//│ res: (1, 2, 3,) & t1 | (3, 4, 5, 4,) & t1 & t2 | (3, 4, 5, 4,) & t2 & ~t1 | (3, 4, 5, 4,) & t2 & ~'a | 'a
//│ Runtime error:
//│   ReferenceError: T1 is not defined


x = 1
//│ x: 1
//│  = 1

t2 = T2 x
//│ t2: 1 & t2
//│   = 1

t1 = T1 t2
//│ t1: 1 & t1 & t2
//│   = 1

t1: T1
t1: T2
//│ res: t1
//│    = 1
//│ res: t2
//│    = 1


class C1[A]: { a: A }
class C2[A]: { a: A }
//│ Defined class C1
//│ Defined class C2

r = if true then C1 {a=x} else C2 {a=(3,4,5,4)}
//│ r: (C1['A .. 1 | 'A] with {a: 1}) | (C2['A0 .. (3, 4, 5, 4,) | 'A0] with {a: (3, 4, 5, 4,)})
//│  = C1 { a: 1 }

case r of { C1 -> r.a | _ -> 0 }
//│ res: 0 | 1
//│    = 1

def x1: (int, bool)
def x2: (string, unit)
//│ x1: (int, bool,)
//│ x2: (string, unit,)

:re
if true then x1 else x2
//│ res: (int | string, bool | unit,)
//│ Runtime error:
//│   ReferenceError: x1 is not defined



def f: ((1,2) | (3,4)) -> anything
//│ f: (1 | 3, 2 | 4,) -> anything

fun (x, y) -> f ((x,y))
//│ res: (1 | 3, 2 | 4,) -> anything
//│    = [Function: res]

def f: ((1,2)&t1 | (3,4)&t2) -> anything
//│ f: ((1, 2,) & t1 | (3, 4,) & t2) -> anything

:e
f ((true,false))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.81: 	f ((true,false))
//│ ║        	^^^^^^^^^^^^^^
//│ ╟── expression of type `true` does not match type `1 | 3`
//│ ║  l.81: 	f ((true,false))
//│ ║        	    ^^^^
//│ ╟── but it flows into tuple literal with expected type `(1, 2,) & t1 | (3, 4,) & t2`
//│ ║  l.81: 	f ((true,false))
//│ ║        	    ^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.77: 	def f: ((1,2)&t1 | (3,4)&t2) -> anything
//│ ╙──      	              ^^^^^^^^^^^^^
//│ res: error
//│ Runtime error:
//│   ReferenceError: f is not defined

:e
fun (x, y) -> f ((x,y))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.99: 	fun (x, y) -> f ((x,y))
//│ ║        	              ^^^^^^^
//│ ╟── expression of type `(?a, ?b,)` does not match type `(1, 2,) & t1 | (3, 4,) & t2`
//│ ║  l.99: 	fun (x, y) -> f ((x,y))
//│ ║        	                  ^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.77: 	def f: ((1,2)&t1 | (3,4)&t2) -> anything
//│ ╙──      	              ^^^^^^^^^^^^^
//│ res: (nothing, nothing,) -> anything
//│    = [Function: res]

fun (x, y) -> f (T1 ((x,y)))
//│ res: (1, 2,) -> anything
//│    = [Function: res]

fun (x, y) -> f (T2 ((x,y)))
//│ res: (3, 4,) -> anything
//│    = [Function: res]

:ns
res = if true then (1,2, "hello") else (true, 3)
//│ res: 'a | (1, 2, "hello",) | (true, 3,)
//│    = [ 1, 2, 'hello' ]

res = if true then (1, 2, 3, 'hello') else (true, 4, false)
hhh = if false then (45,345, 'bye', true) else (false, 3)
t = if false then res else hhh
g = if true then (6,6,6) else res
gwx = g with {x=123}
gwx.x with {y = gwx}
//│ res: Array["hello" | 1 | 2 | 3 | 4 | bool]
//│    = [ 1, 2, 3, 'hello' ]
//│ hhh: Array["bye" | 345 | 3 | 45 | bool]
//│    = [ false, 3 ]
//│ t: Array["bye" | "hello" | 1 | 2 | 345 | 3 | 45 | 4 | bool]
//│  = [ false, 3 ]
//│ g: Array["hello" | 1 | 2 | 3 | 4 | 6 | bool]
//│  = [ 6, 6, 6 ]
//│ gwx: Array["hello" | 1 | 2 | 3 | 4 | 6 | bool] & {x: 123}
//│    = Array { '0': 6, '1': 6, '2': 6, x: 123 }
//│ res: 123 & {y: Array["hello" | 1 | 2 | 3 | 4 | 6 | bool] & {x: 123}}
//│    = [Number: 123] { y: Array { '0': 6, '1': 6, '2': 6, x: 123 } }

def f: (int, bool) -> int
def g: (bool, string, int) -> int
// def h x = (f(x), g(x))
//│ f: (int, bool,) -> int
//│ g: (bool, string, int,) -> int

p1 = if true then (1, 2, 2) else (true, false)
//│ p1: Array[1 | 2 | bool]
//│   = [ 1, 2, 2 ]

def q: Array[int]
q = if true then (1,1) else (1,1,1)
//│ q: Array[int]
//│ Array[1]
//│   <:  q:
//│ Array[int]
//│  = [ 1, 1 ]

def h f = (f (1,2,false), f (1,true))
//│ h: (Array[1 | 2 | bool] -> 'a) -> ('a, 'a,)
//│  = [Function: h]

q1 = (1,1,1,1)
q2 = (1,1)
fx ((a,b,c)) = a + b + c
//│ q1: (1, 1, 1, 1,)
//│   = [ 1, 1, 1, 1 ]
//│ q2: (1, 1,)
//│   = [ 1, 1 ]
//│ fx: (int, int, int,) -> int
//│   = [Function: fx]

:e
fx q1
fx q2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.177: 	fx q1
//│ ║         	^^^^^
//│ ╟── expression of type `(1, 1, 1, 1,)` does not match type `(?a, ?b, ?c,)`
//│ ║  l.166: 	q1 = (1,1,1,1)
//│ ║         	      ^^^^^^^
//│ ╟── but it flows into reference with expected type `(?d, ?e, ?f,)`
//│ ║  l.177: 	fx q1
//│ ║         	   ^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.168: 	fx ((a,b,c)) = a + b + c
//│ ╙──       	     ^^^^^
//│ res: error | int
//│    = 3
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.178: 	fx q2
//│ ║         	^^^^^
//│ ╟── expression of type `(1, 1,)` does not match type `(?a, ?b, ?c,)`
//│ ║  l.167: 	q2 = (1,1)
//│ ║         	      ^^^
//│ ╟── but it flows into reference with expected type `(?d, ?e, ?f,)`
//│ ║  l.178: 	fx q2
//│ ║         	   ^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.168: 	fx ((a,b,c)) = a + b + c
//│ ╙──       	     ^^^^^
//│ res: error | int
//│    = NaN


// :d
q = (1,1)
//│ (1, 1,)
//│   <:  q:
//│ Array[int]
//│  = [ 1, 1 ]

:NoJS
def sum: Array[int] -> int
t1 = (1,2,3,4,5,6)
sum t1
//│ sum: Array[int] -> int
//│ t1: (1, 2, 3, 4, 5, 6,)
//│ res: int

:e
t2 = (1,1,2,true)
sum t2
//│ t2: (1, 1, 2, true,)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.226: 	sum t2
//│ ║         	^^^^^^
//│ ╟── expression of type `true` does not match type `int`
//│ ║  l.225: 	t2 = (1,1,2,true)
//│ ║         	            ^^^^
//│ ╟── but it flows into reference with expected type `Array[int]`
//│ ║  l.226: 	sum t2
//│ ║         	    ^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.217: 	def sum: Array[int] -> int
//│ ╙──       	               ^^^
//│ res: error | int

t2: (1, 1, 2, bool)
t2: Array[int | bool]
//│ res: (1, 1, 2, bool,)
//│ res: Array[bool | int]

class Wrapped[A]: {len: int; inner: Array[A]}
//│ Defined class Wrapped

:NoJS
def tk: Array['a] -> Wrapped['a]
tk ((1,2,3,true,false))
//│ tk: Array['a] -> (Wrapped['a] with {inner: Array['a]})
//│ res: Wrapped['a .. 'a | 1 | 2 | 3 | bool] with {inner: Array['a | 1 | 2 | 3 | bool]}

class Two[A, B]: {fst: Array[A]; snd: Array[B]}
two = Two {fst=(1,2,3); snd=(true,false)}
two.fst
tk (two.snd)
//│ Defined class Two
//│ two: Two['A .. 1 | 2 | 3 | 'A, 'B .. 'B | bool] with {fst: (1, 2, 3,), snd: (true, false,)}
//│ res: (1, 2, 3,)
//│ res: Wrapped['a .. 'a | bool] with {inner: Array['a | bool]}

:e
def a1: Array[int]
a1 = (1,2,true,'hello')
//│ a1: Array[int]
//│ (1, 2, true, "hello",)
//│   <:  a1:
//│ Array[int]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.267: 	a1 = (1,2,true,'hello')
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `true` does not match type `int`
//│ ║  l.267: 	a1 = (1,2,true,'hello')
//│ ║         	          ^^^^
//│ ╟── but it flows into tuple literal with expected type `Array[int]`
//│ ║  l.267: 	a1 = (1,2,true,'hello')
//│ ║         	      ^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.266: 	def a1: Array[int]
//│ ╙──       	              ^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.267: 	a1 = (1,2,true,'hello')
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `"hello"` does not match type `int`
//│ ║  l.267: 	a1 = (1,2,true,'hello')
//│ ║         	               ^^^^^^^
//│ ╟── but it flows into tuple literal with expected type `Array[int]`
//│ ║  l.267: 	a1 = (1,2,true,'hello')
//│ ║         	      ^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.266: 	def a1: Array[int]
//│ ╙──       	              ^^^

def getx p = p.x
def a123: Array[int]
a123 = (1,2,3)
getx (a123 with {x=('hello', a123)})
//│ getx: {x: 'a} -> 'a
//│ a123: Array[int]
//│ (1, 2, 3,)
//│   <:  a123:
//│ Array[int]
//│ res: ("hello", Array[int],)

:NoJS
def append: Array['a] -> Array['b] -> Array['a | 'b]
append ((1,2,false))(((), 'hi'))
//│ append: Array['a] -> Array['a] -> Array['a]
//│ res: Array["hi" | () | 1 | 2 | false]

def ta: T1 & Array[int]
ta = T1 a123
//│ ta: Array[int] & t1
//│ Array[int] & t1
//│   <:  ta:
//│ Array[int] & t1

:d
def tb: T2 & Array[int]
tb = T2 ((1,2,3))
//│ Typed as: (T2 & Array[Int])
//│  where: 
//│ ty[true] (T2 & Array[Int])
//│ -> DNF(Array[Int]{}∧t2)
//│ DNF[true] DNF(Array[Int]{}∧t2)
//│ | ty[true] Int
//│ | -> DNF(int<number>{})
//│ | DNF[true] DNF(int<number>{})
//│ | ~> int<number>
//│ ~> (Array[int<number>] & t2)
//│ Canon: (Array[int<number>] & t2)
//│  where: 
//│ [occs] LinkedHashMap()
//│ [vars] TreeSet()
//│ [bounds] 
//│ [rec] HashSet()
//│ [sub] 
//│ Type after simplification: (Array[int<number>] & t2)
//│  where: 
//│ ty[true] (Array[int<number>] & t2)
//│ -> DNF(Array[int<number>]{}∧t2)
//│ DNF[true] DNF(Array[int<number>]{}∧t2)
//│ | ty[true] int<number>
//│ | -> DNF(int<number>{})
//│ | DNF[true] DNF(int<number>{})
//│ | ~> int<number>
//│ ~> (Array[int<number>] & t2)
//│ Recanon: (Array[int<number>] & t2)
//│  where: 
//│ [occs] LinkedHashMap()
//│ [vars] TreeSet()
//│ [bounds] 
//│ [rec] HashSet()
//│ [sub] 
//│ Resimplified: (Array[int<number>] & t2)
//│  where: 
//│ Recons: (Array[int<number>] & t2)
//│ tb: Array[int] & t2
//│ 1. Typing term (T2 (((1, 2, 3,)),))
//│ | 1. Typing term T2
//│ | 1. : [((α0') -> (α0' & t2))]
//│ | 1. Typing term (((1, 2, 3,)),)
//│ | | 1. Typing term ((1, 2, 3,))
//│ | | | 1. Typing term (1, 2, 3,)
//│ | | | | 1. Typing term 1
//│ | | | | 1. : 1<int,number>
//│ | | | | 1. Typing term 2
//│ | | | | 1. : 2<int,number>
//│ | | | | 1. Typing term 3
//│ | | | | 1. : 3<int,number>
//│ | | | 1. : (1<int,number>, 2<int,number>, 3<int,number>)
//│ | | 1. : (1<int,number>, 2<int,number>, 3<int,number>)
//│ | 1. : ((1<int,number>, 2<int,number>, 3<int,number>))
//│ | CONSTRAIN [[((α0') -> (α0' & t2))]] <! ([((1<int,number>, 2<int,number>, 3<int,number>))] -> α1')
//│ |   where α0' <: ⊤
//│ | C [[((α0') -> (α0' & t2))]] <! ([((1<int,number>, 2<int,number>, 3<int,number>))] -> α1')
//│ | | C [((α0') -> (α0' & t2))] <! ([((1<int,number>, 2<int,number>, 3<int,number>))] -> α1')
//│ | | | C ((α0') -> (α0' & t2)) <! ([((1<int,number>, 2<int,number>, 3<int,number>))] -> α1')
//│ | | | | C [((1<int,number>, 2<int,number>, 3<int,number>))] <! (α0')
//│ | | | | | C ((1<int,number>, 2<int,number>, 3<int,number>)) <! (α0')
//│ | | | | | | C (1<int,number>, 2<int,number>, 3<int,number>) <! α0'
//│ | | | | | | | C (1<int,number>, 2<int,number>, 3<int,number>) <! ⊤
//│ | | | | C (α0' & t2) <! α1'
//│ 1. : α1'
//│ Typed as: α2
//│  where: α2 :> (α3 & t2), α3 :> (1<int,number>, 2<int,number>, 3<int,number>) <: ⊤
//│ ty[true] α2
//│ | Consider α2 List((α3 & t2)) List()
//│ | Consider α3 List((1<int,number>, 2<int,number>, 3<int,number>)) List(⊤)
//│ -> DNF(α2 | {}∧t2∧α3 | (1<int,number>, 2<int,number>, 3<int,number>){}∧t2)
//│ DNF[true] DNF(α2 | {}∧t2∧α3 | (1<int,number>, 2<int,number>, 3<int,number>){}∧t2)
//│ | Renewed α2 ~> α4
//│ | Renewed α3 ~> α5
//│ | ty[true] 1<int,number>
//│ | -> DNF(1<int,number>{})
//│ | DNF[true] DNF(1<int,number>{})
//│ | ~> 1<int,number>
//│ | ty[true] 2<int,number>
//│ | -> DNF(2<int,number>{})
//│ | DNF[true] DNF(2<int,number>{})
//│ | ~> 2<int,number>
//│ | ty[true] 3<int,number>
//│ | -> DNF(3<int,number>{})
//│ | DNF[true] DNF(3<int,number>{})
//│ | ~> 3<int,number>
//│ ~> (((1<int,number>, 2<int,number>, 3<int,number>) & t2) | ((t2 & α5) | α4))
//│ Canon: (((1<int,number>, 2<int,number>, 3<int,number>) & t2) | ((t2 & α5) | α4))
//│  where: 
//│ ! true α5 None
//│ [occs] LinkedHashMap((true,α5) -> HashSet(α5), (true,α4) -> HashSet(α4))
//│ [vars] TreeSet(α4, α5)
//│ [bounds] 
//│ [rec] HashSet()
//│ [!] α4
//│ [!] α5
//│ [sub] α4 -> None, α5 -> None
//│ Type after simplification: ((1<int,number>, 2<int,number>, 3<int,number>) & t2)
//│  where: 
//│ ty[true] ((1<int,number>, 2<int,number>, 3<int,number>) & t2)
//│ -> DNF((1<int,number>, 2<int,number>, 3<int,number>){}∧t2)
//│ DNF[true] DNF((1<int,number>, 2<int,number>, 3<int,number>){}∧t2)
//│ | ty[true] 1<int,number>
//│ | -> DNF(1<int,number>{})
//│ | DNF[true] DNF(1<int,number>{})
//│ | ~> 1<int,number>
//│ | ty[true] 2<int,number>
//│ | -> DNF(2<int,number>{})
//│ | DNF[true] DNF(2<int,number>{})
//│ | ~> 2<int,number>
//│ | ty[true] 3<int,number>
//│ | -> DNF(3<int,number>{})
//│ | DNF[true] DNF(3<int,number>{})
//│ | ~> 3<int,number>
//│ ~> ((1<int,number>, 2<int,number>, 3<int,number>) & t2)
//│ Recanon: ((1<int,number>, 2<int,number>, 3<int,number>) & t2)
//│  where: 
//│ [occs] LinkedHashMap()
//│ [vars] TreeSet()
//│ [bounds] 
//│ [rec] HashSet()
//│ [sub] 
//│ Resimplified: ((1<int,number>, 2<int,number>, 3<int,number>) & t2)
//│  where: 
//│ Recons: ((1<int,number>, 2<int,number>, 3<int,number>) & t2)
//│ Typed as: (T2 & Array[Int])
//│  where: 
//│ ty[true] (T2 & Array[Int])
//│ -> DNF(Array[Int]{}∧t2)
//│ DNF[true] DNF(Array[Int]{}∧t2)
//│ | ty[true] Int
//│ | -> DNF(int<number>{})
//│ | DNF[true] DNF(int<number>{})
//│ | ~> int<number>
//│ ~> (Array[int<number>] & t2)
//│ Canon: (Array[int<number>] & t2)
//│  where: 
//│ [occs] LinkedHashMap()
//│ [vars] TreeSet()
//│ [bounds] 
//│ [rec] HashSet()
//│ [sub] 
//│ Type after simplification: (Array[int<number>] & t2)
//│  where: 
//│ ty[true] (Array[int<number>] & t2)
//│ -> DNF(Array[int<number>]{}∧t2)
//│ DNF[true] DNF(Array[int<number>]{}∧t2)
//│ | ty[true] int<number>
//│ | -> DNF(int<number>{})
//│ | DNF[true] DNF(int<number>{})
//│ | ~> int<number>
//│ ~> (Array[int<number>] & t2)
//│ Recanon: (Array[int<number>] & t2)
//│  where: 
//│ [occs] LinkedHashMap()
//│ [vars] TreeSet()
//│ [bounds] 
//│ [rec] HashSet()
//│ [sub] 
//│ Resimplified: (Array[int<number>] & t2)
//│  where: 
//│ Recons: (Array[int<number>] & t2)
//│ (1, 2, 3,) & t2
//│   <:  tb:
//│ Array[int] & t2
//│ CONSTRAIN α6 <! (T2 & Array[Int])
//│   where α6 :> (α7 & t2), α7 :> (1<int,number>, 2<int,number>, 3<int,number>) <: ⊤
//│ C α6 <! (T2 & Array[Int])
//│ | C (α7 & t2) <! (T2 & Array[Int])
//│ | | C (α7 & t2) <! T2
//│ | | | C (α7 & t2) <! t2
//│ | | | | ARGH  DNF({}∧t2∧α7)  <!  DNF({}∧t2)
//│ | | | | | C α7 <! ⊤
//│ | | C (α7 & t2) <! Array[Int]
//│ | | | C (α7 & t2) <! Array[Int]
//│ | | | | ARGH  DNF({}∧t2∧α7)  <!  DNF(Array[Int]{})
//│ | | | | | C α7 <! (Array[Int] | ~(t2))
//│ | | | | | | C (1<int,number>, 2<int,number>, 3<int,number>) <! (Array[Int] | ~(t2))
//│ | | | | | | | ARGH  DNF((1<int,number>, 2<int,number>, 3<int,number>){})  <!  DNF(Array[Int]{} | ~t2|None)
//│ | | | | | | | | Consider (1<int,number>, 2<int,number>, 3<int,number>){} <: DNF(Array[Int]{} | ~t2|None)
//│ | | | | | | | | Possible: List(Array[Int]{}, ~t2|None)
//│ | | | | | | | | Factorized: List(Array[Int], ~(t2))
//│ | | | | | | | | A  (1<int,number>, 2<int,number>, 3<int,number>){}  %  List()  <!  List(Array[Int], ~(t2))  %  ⊥
//│ | | | | | | | | | A  (1<int,number>, 2<int,number>, 3<int,number>){}  %  List()  <!  List(~(t2))  %  |Some(Left(Array[Int]))
//│ | | | | | | | | | | A  (1<int,number>, 2<int,number>, 3<int,number>){}  %  List(t2)  <!  List()  %  |Some(Left(Array[Int]))
//│ | | | | | | | | | | | A  (1<int,number>, 2<int,number>, 3<int,number>){}∧t2  %  List()  <!  List()  %  |Some(Left(Array[Int]))
//│ | | | | | | | | | | | | C Array[((1<int,number> | 2<int,number>) | 3<int,number>)] <! Int
//│ | | | | | | | | | | | | | C Array[((1<int,number> | 2<int,number>) | 3<int,number>)] <! int<number>
//│ | | | | | | | | | | | | | | CONSTRAINT FAILURE: Array[((1<int,number> | 2<int,number>) | 3<int,number>)] <: int<number>
//│ | | | | | | | | | | | | | | CTX: List(List(Array[((1<int,number> | 2<int,number>) | 3<int,number>)] <: int<number> [‹tuple literal:Loc(34,39,Yicong:+322)›] [‹expression›], Array[((1<int,number> | 2<int,number>) | 3<int,number>)] <: Int [‹tuple literal:Loc(34,39,Yicong:+322)›] [‹type reference:Loc(19,22,Yicong:+322)›], (1<int,number>, 2<int,number>, 3<int,number>) <: (Array[Int] | ~(t2)) [‹tuple literal:Loc(34,39,Yicong:+322)›] [‹expression›], α7 <: (Array[Int] | ~(t2)) [‹expression›] [‹expression›], (α7 & t2) <: Array[Int] [‹expression›] [‹expression›], (α7 & t2) <: Array[Int] [‹expression›] [‹applied type reference:Loc(13,23,Yicong:+322)›], (α7 & t2) <: (T2 & Array[Int]) [‹expression›] [‹intersection type:Loc(8,23,Yicong:+322)›], α6 <: (T2 & Array[Int]) [‹application:Loc(29,39,Yicong:+322)›] [‹intersection type:Loc(8,23,Yicong:+322)›]))
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.323: 	tb = T2 ((1,2,3))
//│ ║         	^^^^^^^^^^^^^^^
//│ ╟── expression of type `Array[1 | 2 | 3]` does not match type `int`
//│ ║  l.323: 	tb = T2 ((1,2,3))
//│ ║         	          ^^^^^
//│ ╟── but it flows into application with expected type `Array[int] & t2`
//│ ║  l.323: 	tb = T2 ((1,2,3))
//│ ║         	     ^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.322: 	def tb: T2 & Array[int]
//│ ╙──       	                   ^^^


def k: (true, false, 3) & Array[int | bool]
//│ k: (true, false, 3,)

def gett1 p q = case p of {T1 -> p | _ -> q}
gett1 ta (T1 123)
def gt: (T1 & Array[int | bool]) -> Array[int]
gt ta
//│ gett1: (t1 & 'a | ~t1) -> 'a -> 'a
//│ res: 123 & t1 | Array[int] & t1
//│ gt: (Array[bool | int] & t1) -> Array[int]
//│ res: Array[int]

